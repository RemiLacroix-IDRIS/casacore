<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>casacore: casacore::Array&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">casacore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecasacore.html">casacore</a></li><li class="navelem"><a class="el" href="classcasacore_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcasacore_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">casacore::Array&lt; T, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Arrays__module.html">Arrays_module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class is the base class for the <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, and <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a> subclasses.  
 <a href="classcasacore_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8h_source.html">Array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for casacore::Array&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcasacore_1_1Array.png" usemap="#casacore::Array&lt; T, Alloc &gt;_map" alt=""/>
  <map id="casacore::Array&lt; T, Alloc &gt;_map" name="casacore::Array&lt; T, Alloc &gt;_map">
<area href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. " alt="casacore::ArrayBase" shape="rect" coords="0,0,826,24"/>
<area href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. " alt="casacore::Cube&lt; T, Alloc &gt;" shape="rect" coords="836,112,1662,136"/>
<area href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. " alt="casacore::Matrix&lt; T, Alloc &gt;" shape="rect" coords="836,168,1662,192"/>
<area href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. " alt="casacore::Vector&lt; T, Alloc &gt;" shape="rect" coords="836,224,1662,248"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; Bool &gt;" shape="rect" coords="836,280,1662,304"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; casacore::GaussianBeam &gt;" shape="rect" coords="836,336,1662,360"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;" shape="rect" coords="836,392,1662,416"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; Complex &gt;" shape="rect" coords="836,448,1662,472"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; Float &gt;" shape="rect" coords="836,504,1662,528"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; FType &gt;" shape="rect" coords="836,560,1662,584"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; Int &gt;" shape="rect" coords="836,616,1662,640"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; Int64 &gt;" shape="rect" coords="836,672,1662,696"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; ArgType &gt;" shape="rect" coords="836,728,1662,752"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;" shape="rect" coords="836,784,1662,808"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;" shape="rect" coords="836,840,1662,864"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Bool &gt;" shape="rect" coords="836,896,1662,920"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;" shape="rect" coords="836,952,1662,976"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MDirection &gt;" shape="rect" coords="836,1008,1662,1032"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MeasComet * &gt;" shape="rect" coords="836,1064,1662,1088"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MFrequency &gt;" shape="rect" coords="836,1120,1662,1144"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MPosition &gt;" shape="rect" coords="836,1176,1662,1200"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Quantum &gt;" shape="rect" coords="836,1232,1662,1256"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;" shape="rect" coords="836,1288,1662,1312"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;" shape="rect" coords="836,1344,1662,1368"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Slicer * &gt;" shape="rect" coords="836,1400,1662,1424"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;" shape="rect" coords="836,1456,1662,1480"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::String &gt;" shape="rect" coords="836,1512,1662,1536"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Unit &gt;" shape="rect" coords="836,1568,1662,1592"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;" shape="rect" coords="836,1624,1662,1648"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1680,1662,1704"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1736,1662,1760"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1792,1662,1816"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Domain &gt;" shape="rect" coords="836,1848,1662,1872"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; double &gt;" shape="rect" coords="836,1904,1662,1928"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Float &gt;" shape="rect" coords="836,1960,1662,1984"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; FType &gt;" shape="rect" coords="836,2016,1662,2040"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Int &gt;" shape="rect" coords="836,2072,1662,2096"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Int64 &gt;" shape="rect" coords="836,2128,1662,2152"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; rownr_t &gt;" shape="rect" coords="836,2184,1662,2208"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; size_t &gt;" shape="rect" coords="836,2240,1662,2264"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Type &gt;" shape="rect" coords="836,2296,1662,2320"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;" shape="rect" coords="836,2352,1662,2376"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;" shape="rect" coords="836,2408,1662,2432"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;" shape="rect" coords="836,2464,1662,2488"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;" shape="rect" coords="836,2520,1662,2544"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;" shape="rect" coords="836,2576,1662,2600"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;" shape="rect" coords="836,2632,1662,2656"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;" shape="rect" coords="836,2688,1662,2712"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;" shape="rect" coords="836,2744,1662,2768"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;" shape="rect" coords="836,2800,1662,2824"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; uInt &gt;" shape="rect" coords="836,2856,1662,2880"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1BaseIteratorSTL.html">BaseIteratorSTL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the function <a class="el" href="classcasacore_1_1Array.html#ab04f0eaa446f7521324798154d94845a" title="Get the begin iterator object for any array. ">begin()</a> and <a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end()</a> for a detailed description of the STL iterator capability.  <a href="classcasacore_1_1Array_1_1BaseIteratorSTL.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1Array_1_1uninitializedType.html">uninitializedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a tag for the constructor that may be used to construct an uninitialized <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>.  <a href="structcasacore_1_1Array_1_1uninitializedType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4da33780a9006dbbac0c73c855d56265"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4da33780a9006dbbac0c73c855d56265">Array</a> (const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a4da33780a9006dbbac0c73c855d56265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result has dimensionality of zero, and nelements is zero.  <a href="#a4da33780a9006dbbac0c73c855d56265">More...</a><br/></td></tr>
<tr class="separator:a4da33780a9006dbbac0c73c855d56265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac209b130227b7f50cf7292bcb843d808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac209b130227b7f50cf7292bcb843d808">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:ac209b130227b7f50cf7292bcb843d808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape, i.e.  <a href="#ac209b130227b7f50cf7292bcb843d808">More...</a><br/></td></tr>
<tr class="separator:ac209b130227b7f50cf7292bcb843d808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71eebceb6e5104fe22a4ede8a022196"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa71eebceb6e5104fe22a4ede8a022196">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T &amp;initialValue, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:aa71eebceb6e5104fe22a4ede8a022196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape and initialize it with the initial value.  <a href="#aa71eebceb6e5104fe22a4ede8a022196">More...</a><br/></td></tr>
<tr class="separator:aa71eebceb6e5104fe22a4ede8a022196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04a8cf8caf6891b467f23a3a5361e32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa04a8cf8caf6891b467f23a3a5361e32">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, <a class="el" href="structcasacore_1_1Array_1_1uninitializedType.html">uninitializedType</a>, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:aa04a8cf8caf6891b467f23a3a5361e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create an uninitialized array.  <a href="#aa04a8cf8caf6891b467f23a3a5361e32">More...</a><br/></td></tr>
<tr class="separator:aa04a8cf8caf6891b467f23a3a5361e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dbee48e8ca7e9a7a9176774a474300"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a91dbee48e8ca7e9a7a9176774a474300">Array</a> (std::initializer_list&lt; T &gt; list, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a91dbee48e8ca7e9a7a9176774a474300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a one-dimensional array from an initializer list.  <a href="#a91dbee48e8ca7e9a7a9176774a474300">More...</a><br/></td></tr>
<tr class="separator:a91dbee48e8ca7e9a7a9176774a474300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1849e5cdbc5ef3fec4b60fab9fd98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afca1849e5cdbc5ef3fec4b60fab9fd98">Array</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:afca1849e5cdbc5ef3fec4b60fab9fd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">After construction, this and other reference the same storage.  <a href="#afca1849e5cdbc5ef3fec4b60fab9fd98">More...</a><br/></td></tr>
<tr class="separator:afca1849e5cdbc5ef3fec4b60fab9fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb257b4dd3669dabc1513835bfc31439"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#abb257b4dd3669dabc1513835bfc31439">Array</a> (<a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;source) noexcept</td></tr>
<tr class="memdesc:abb257b4dd3669dabc1513835bfc31439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source will be empty after this call.  <a href="#abb257b4dd3669dabc1513835bfc31439">More...</a><br/></td></tr>
<tr class="separator:abb257b4dd3669dabc1513835bfc31439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34454828b83ffca480f3a82742bd46c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a34454828b83ffca480f3a82742bd46c8">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy=<a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a>, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a34454828b83ffca480f3a82742bd46c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> of a given shape from a pointer.  <a href="#a34454828b83ffca480f3a82742bd46c8">More...</a><br/></td></tr>
<tr class="separator:a34454828b83ffca480f3a82742bd46c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1accee4461916531b4048acf212471d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1accee4461916531b4048acf212471d6">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T *storage)</td></tr>
<tr class="memdesc:a1accee4461916531b4048acf212471d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> of a given shape from a pointer.  <a href="#a1accee4461916531b4048acf212471d6">More...</a><br/></td></tr>
<tr class="separator:a1accee4461916531b4048acf212471d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f453c8e68d00052188354f47e47d6f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a91f453c8e68d00052188354f47e47d6f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a91f453c8e68d00052188354f47e47d6f">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, InputIterator startIter, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a91f453c8e68d00052188354f47e47d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an iterator and a shape.  <a href="#a91f453c8e68d00052188354f47e47d6f">More...</a><br/></td></tr>
<tr class="separator:a91f453c8e68d00052188354f47e47d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc68b330b8326055c06fa80a2d8396"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a34cc68b330b8326055c06fa80a2d8396">~Array</a> () noexcept</td></tr>
<tr class="memdesc:a34cc68b330b8326055c06fa80a2d8396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up storage only if this array was the last reference to it.  <a href="#a34cc68b330b8326055c06fa80a2d8396">More...</a><br/></td></tr>
<tr class="separator:a34cc68b330b8326055c06fa80a2d8396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373ea1ec1990b5b0bb2bf07c74bcd71"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5373ea1ec1990b5b0bb2bf07c74bcd71">makeArray</a> () const override</td></tr>
<tr class="memdesc:a5373ea1ec1990b5b0bb2bf07c74bcd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an empty array of the same template type.  <a href="#a5373ea1ec1990b5b0bb2bf07c74bcd71">More...</a><br/></td></tr>
<tr class="separator:a5373ea1ec1990b5b0bb2bf07c74bcd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d80d945127590f96e5215c60f8c383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab0d80d945127590f96e5215c60f8c383">assign</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:ab0d80d945127590f96e5215c60f8c383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the other array to this array.  <a href="#ab0d80d945127590f96e5215c60f8c383">More...</a><br/></td></tr>
<tr class="separator:ab0d80d945127590f96e5215c60f8c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07d5a061abc30ed33d6f545edb1a030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad07d5a061abc30ed33d6f545edb1a030">assignBase</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other, bool checkType=true) override</td></tr>
<tr class="memdesc:ad07d5a061abc30ed33d6f545edb1a030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the source array to this array.  <a href="#ad07d5a061abc30ed33d6f545edb1a030">More...</a><br/></td></tr>
<tr class="separator:ad07d5a061abc30ed33d6f545edb1a030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262338b21281496873e0e7fdd625c5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a262338b21281496873e0e7fdd625c5f9">set</a> (const T &amp;<a class="el" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">value</a>)</td></tr>
<tr class="memdesc:a262338b21281496873e0e7fdd625c5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every element of the array to "value." Also could use the assignment operator which assigns an array from a scalar.  <a href="#a262338b21281496873e0e7fdd625c5f9">More...</a><br/></td></tr>
<tr class="separator:a262338b21281496873e0e7fdd625c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c566146ad72351dafb49b3b0e4af891"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a5c566146ad72351dafb49b3b0e4af891"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5c566146ad72351dafb49b3b0e4af891">apply</a> (Callable function)</td></tr>
<tr class="memdesc:a5c566146ad72351dafb49b3b0e4af891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the function to every element of the array.  <a href="#a5c566146ad72351dafb49b3b0e4af891">More...</a><br/></td></tr>
<tr class="separator:a5c566146ad72351dafb49b3b0e4af891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115142801f497760a6859622ec4ea25b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a115142801f497760a6859622ec4ea25b">reference</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:a115142801f497760a6859622ec4ea25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">After invocation, this array and other reference the same storage.  <a href="#a115142801f497760a6859622ec4ea25b">More...</a><br/></td></tr>
<tr class="separator:a115142801f497760a6859622ec4ea25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea16e489e81114c9272870cea29c1a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aea16e489e81114c9272870cea29c1a9a">assign_conforming</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:aea16e489e81114c9272870cea29c1a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values in other to this.  <a href="#aea16e489e81114c9272870cea29c1a9a">More...</a><br/></td></tr>
<tr class="separator:aea16e489e81114c9272870cea29c1a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9841e837cafcab1629b175f63e7a797"><td class="memTemplParams" colspan="2">template&lt;typename MaskAlloc &gt; </td></tr>
<tr class="memitem:ae9841e837cafcab1629b175f63e7a797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ae9841e837cafcab1629b175f63e7a797">assign_conforming</a> (const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T, Alloc, MaskAlloc &gt; &amp;<a class="el" href="namespacecasacore.html#ac570e761f6a12e7166c7bbd30f465ff3">marray</a>)</td></tr>
<tr class="memdesc:ae9841e837cafcab1629b175f63e7a797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to this those values in marray whose corresponding elements in marray's mask are true.  <a href="#ae9841e837cafcab1629b175f63e7a797">More...</a><br/></td></tr>
<tr class="separator:ae9841e837cafcab1629b175f63e7a797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676e2ee92bf96cf7517e62f3157c6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad676e2ee92bf96cf7517e62f3157c6be">operator=</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:ad676e2ee92bf96cf7517e62f3157c6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO we should change the semantics.  <a href="#ad676e2ee92bf96cf7517e62f3157c6be">More...</a><br/></td></tr>
<tr class="separator:ad676e2ee92bf96cf7517e62f3157c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b16703273eb8a785ca1921040938a9"><td class="memTemplParams" colspan="2">template&lt;typename MaskAlloc &gt; </td></tr>
<tr class="memitem:a03b16703273eb8a785ca1921040938a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a03b16703273eb8a785ca1921040938a9">operator=</a> (const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T, Alloc, MaskAlloc &gt; &amp;<a class="el" href="namespacecasacore.html#ac570e761f6a12e7166c7bbd30f465ff3">marray</a>)</td></tr>
<tr class="memdesc:a03b16703273eb8a785ca1921040938a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classcasacore_1_1Array.html#aea16e489e81114c9272870cea29c1a9a" title="Copy the values in other to this. ">assign_conforming()</a>.  <a href="#a03b16703273eb8a785ca1921040938a9">More...</a><br/></td></tr>
<tr class="separator:a03b16703273eb8a785ca1921040938a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4bddd1678989d4bcac2b407082c5fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ade4bddd1678989d4bcac2b407082c5fd">operator=</a> (<a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ade4bddd1678989d4bcac2b407082c5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move operator takes the storage from the given array.  <a href="#ade4bddd1678989d4bcac2b407082c5fd">More...</a><br/></td></tr>
<tr class="separator:ade4bddd1678989d4bcac2b407082c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887eef6335d241f56c7bde35d6373119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a887eef6335d241f56c7bde35d6373119">operator=</a> (const T &amp;<a class="el" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">value</a>)</td></tr>
<tr class="memdesc:a887eef6335d241f56c7bde35d6373119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every element of this array to "value".  <a href="#a887eef6335d241f56c7bde35d6373119">More...</a><br/></td></tr>
<tr class="separator:a887eef6335d241f56c7bde35d6373119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06da349f8606994e7d53c73d4166e249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a06da349f8606994e7d53c73d4166e249">copy</a> () const </td></tr>
<tr class="memdesc:a06da349f8606994e7d53c73d4166e249"><td class="mdescLeft">&#160;</td><td class="mdescRight">This makes a copy of the array and returns it.  <a href="#a06da349f8606994e7d53c73d4166e249">More...</a><br/></td></tr>
<tr class="separator:a06da349f8606994e7d53c73d4166e249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466ba62f5a479162c737bc4f000c9335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a466ba62f5a479162c737bc4f000c9335">copyMatchingPart</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;from)</td></tr>
<tr class="memdesc:a466ba62f5a479162c737bc4f000c9335"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the matching part of from array to this array.  <a href="#a466ba62f5a479162c737bc4f000c9335">More...</a><br/></td></tr>
<tr class="separator:a466ba62f5a479162c737bc4f000c9335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab566986400a325d01e4495fa754d6dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab566986400a325d01e4495fa754d6dc6">unique</a> ()</td></tr>
<tr class="memdesc:ab566986400a325d01e4495fa754d6dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ensures that this array does not reference any other storage.  <a href="#ab566986400a325d01e4495fa754d6dc6">More...</a><br/></td></tr>
<tr class="separator:ab566986400a325d01e4495fa754d6dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f857fd93c3b794b0068fc3ac24d058"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a52f857fd93c3b794b0068fc3ac24d058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a52f857fd93c3b794b0068fc3ac24d058">tovector</a> (std::vector&lt; T, U &gt; &amp;out) const </td></tr>
<tr class="memdesc:a52f857fd93c3b794b0068fc3ac24d058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an STL vector from an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>.  <a href="#a52f857fd93c3b794b0068fc3ac24d058">More...</a><br/></td></tr>
<tr class="separator:a52f857fd93c3b794b0068fc3ac24d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dd6550574969d261d8d658584f86be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad5dd6550574969d261d8d658584f86be">tovector</a> () const </td></tr>
<tr class="separator:ad5dd6550574969d261d8d658584f86be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c71b17d672896c23fec325ffe2ad0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af3c71b17d672896c23fec325ffe2ad0b">reform</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>) const </td></tr>
<tr class="memdesc:af3c71b17d672896c23fec325ffe2ad0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is occasionally useful to have an array which access the same storage appear to have a different shape.  <a href="#af3c71b17d672896c23fec325ffe2ad0b">More...</a><br/></td></tr>
<tr class="separator:af3c71b17d672896c23fec325ffe2ad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd197a0d301001430c90f2aa0f2f1d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#acd197a0d301001430c90f2aa0f2f1d62">reformOrResize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, size_t resizePercentage=0, bool resizeIfNeeded=true)</td></tr>
<tr class="memdesc:acd197a0d301001430c90f2aa0f2f1d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Having an array that can be reused without requiring reallocation can be useful for large arrays.  <a href="#acd197a0d301001430c90f2aa0f2f1d62">More...</a><br/></td></tr>
<tr class="separator:acd197a0d301001430c90f2aa0f2f1d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de93ce96905febdc3d0b3ff81d4730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a35de93ce96905febdc3d0b3ff81d4730">adjustLastAxis</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, size_t resizePercentage=0, bool resizeIfNeeded=true)</td></tr>
<tr class="memdesc:a35de93ce96905febdc3d0b3ff81d4730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to extend or reduce the last dimension of an array.  <a href="#a35de93ce96905febdc3d0b3ff81d4730">More...</a><br/></td></tr>
<tr class="separator:a35de93ce96905febdc3d0b3ff81d4730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71108e95be60f8e1b01a702bfffe8bf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a71108e95be60f8e1b01a702bfffe8bf0">capacity</a> () const </td></tr>
<tr class="memdesc:a71108e95be60f8e1b01a702bfffe8bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements allocated.  <a href="#a71108e95be60f8e1b01a702bfffe8bf0">More...</a><br/></td></tr>
<tr class="separator:a71108e95be60f8e1b01a702bfffe8bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae2208959f88668ee4c8c4c4ad7aa5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#adae2208959f88668ee4c8c4c4ad7aa5d">nonDegenerate</a> (size_t startingAxis=0, bool throwIfError=true) const </td></tr>
<tr class="memdesc:adae2208959f88668ee4c8c4c4ad7aa5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These member functions remove degenerate (ie.  <a href="#adae2208959f88668ee4c8c4c4ad7aa5d">More...</a><br/></td></tr>
<tr class="separator:adae2208959f88668ee4c8c4c4ad7aa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990566528d1a321765cae138a80288e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a990566528d1a321765cae138a80288e7">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes) const </td></tr>
<tr class="separator:a990566528d1a321765cae138a80288e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330f70186897ee7b7c4079cf536bbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac330f70186897ee7b7c4079cf536bbd4">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other, size_t startingAxis=0, bool throwIfError=true)</td></tr>
<tr class="separator:ac330f70186897ee7b7c4079cf536bbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1559203d287234bb4e1e4059c7c9601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af1559203d287234bb4e1e4059c7c9601">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="separator:af1559203d287234bb4e1e4059c7c9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f38e7fd261f17fcf651b21aa471ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad37f38e7fd261f17fcf651b21aa471ce">removeDegenerate</a> (size_t startingAxis=0, bool throwIfError=true)</td></tr>
<tr class="memdesc:ad37f38e7fd261f17fcf651b21aa471ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove degenerate axes from this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object.  <a href="#ad37f38e7fd261f17fcf651b21aa471ce">More...</a><br/></td></tr>
<tr class="separator:ad37f38e7fd261f17fcf651b21aa471ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83265707db5b4243c324377d2331a4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a83265707db5b4243c324377d2331a4e4">removeDegenerate</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="separator:a83265707db5b4243c324377d2331a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a69e51ca86b397f09d0355db5805a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a048a69e51ca86b397f09d0355db5805a">addDegenerate</a> (size_t numAxes) const </td></tr>
<tr class="memdesc:a048a69e51ca86b397f09d0355db5805a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function returns an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>.  <a href="#a048a69e51ca86b397f09d0355db5805a">More...</a><br/></td></tr>
<tr class="separator:a048a69e51ca86b397f09d0355db5805a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e2b4fa2692b4e80dafe86fa22ce50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a95e2b4fa2692b4e80dafe86fa22ce50c">addDegenerate</a> (size_t numAxes)</td></tr>
<tr class="separator:a95e2b4fa2692b4e80dafe86fa22ce50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899d0338a3ca99af49f6d4c398606698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a899d0338a3ca99af49f6d4c398606698">resize</a> ()</td></tr>
<tr class="memdesc:a899d0338a3ca99af49f6d4c398606698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this array a different shape.  <a href="#a899d0338a3ca99af49f6d4c398606698">More...</a><br/></td></tr>
<tr class="separator:a899d0338a3ca99af49f6d4c398606698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0574bddabd370088a9259a2e5003d413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0574bddabd370088a9259a2e5003d413">resize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, bool copyValues=false) override</td></tr>
<tr class="memdesc:a0574bddabd370088a9259a2e5003d413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the array and optionally copy the values.  <a href="#a0574bddabd370088a9259a2e5003d413">More...</a><br/></td></tr>
<tr class="separator:a0574bddabd370088a9259a2e5003d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4971d08ebde664122131746726739fc5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4971d08ebde664122131746726739fc5">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;)</td></tr>
<tr class="memdesc:a4971d08ebde664122131746726739fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a single element of the array.  <a href="#a4971d08ebde664122131746726739fc5">More...</a><br/></td></tr>
<tr class="separator:a4971d08ebde664122131746726739fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2620d6fce204e69a0328ddb0dcda1b3d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2620d6fce204e69a0328ddb0dcda1b3d">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;) const </td></tr>
<tr class="separator:a2620d6fce204e69a0328ddb0dcda1b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf129d788e368e9ac50dd7a5344b9f65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#abf129d788e368e9ac50dd7a5344b9f65">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end</a>)</td></tr>
<tr class="memdesc:abf129d788e368e9ac50dd7a5344b9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an array section extending from start to end (inclusive).  <a href="#abf129d788e368e9ac50dd7a5344b9f65">More...</a><br/></td></tr>
<tr class="separator:abf129d788e368e9ac50dd7a5344b9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27132f638cc8b385f8350a7ff2548981"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a27132f638cc8b385f8350a7ff2548981">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end</a>) const </td></tr>
<tr class="separator:a27132f638cc8b385f8350a7ff2548981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e0ddc9b58421a0077952f7d3b815dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a59e0ddc9b58421a0077952f7d3b815dc">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end</a>, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;inc)</td></tr>
<tr class="memdesc:a59e0ddc9b58421a0077952f7d3b815dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Along the ith axis, every inc[i]'th element is chosen.  <a href="#a59e0ddc9b58421a0077952f7d3b815dc">More...</a><br/></td></tr>
<tr class="separator:a59e0ddc9b58421a0077952f7d3b815dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b4ec4fb8f949640294c57e8cbbf57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2c3b4ec4fb8f949640294c57e8cbbf57">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end</a>, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;inc) const </td></tr>
<tr class="separator:a2c3b4ec4fb8f949640294c57e8cbbf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f6de57e791b5ad24a6af6911c73aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa1f6de57e791b5ad24a6af6911c73aa9">operator()</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;)</td></tr>
<tr class="memdesc:aa1f6de57e791b5ad24a6af6911c73aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an array section using a <a class="el" href="classcasacore_1_1Slicer.html" title="Specify which elements to extract from an n-dimensional array. ">Slicer</a>.  <a href="#aa1f6de57e791b5ad24a6af6911c73aa9">More...</a><br/></td></tr>
<tr class="separator:aa1f6de57e791b5ad24a6af6911c73aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbbcc796ce0b8b0cb9f497a1e308b8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3fbbcc796ce0b8b0cb9f497a1e308b8c">operator()</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;) const </td></tr>
<tr class="separator:a3fbbcc796ce0b8b0cb9f497a1e308b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3087df9a8e98a289d7d74570b60d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9ff3087df9a8e98a289d7d74570b60d5">getSection</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;) const override</td></tr>
<tr class="memdesc:a9ff3087df9a8e98a289d7d74570b60d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a section of an array.  <a href="#a9ff3087df9a8e98a289d7d74570b60d5">More...</a><br/></td></tr>
<tr class="separator:a9ff3087df9a8e98a289d7d74570b60d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a19f84dcd3586e41f394cf1df4b73ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3a19f84dcd3586e41f394cf1df4b73ae">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:a3a19f84dcd3586e41f394cf1df4b73ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subset given by the i-th value of the last axis.  <a href="#a3a19f84dcd3586e41f394cf1df4b73ae">More...</a><br/></td></tr>
<tr class="separator:a3a19f84dcd3586e41f394cf1df4b73ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a44176d28168780f1d4b0491a75704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a24a44176d28168780f1d4b0491a75704">diagonals</a> (size_t firstAxis=0, long long diag=0) const </td></tr>
<tr class="memdesc:a24a44176d28168780f1d4b0491a75704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diagonal of each matrix part in the full array.  <a href="#a24a44176d28168780f1d4b0491a75704">More...</a><br/></td></tr>
<tr class="separator:a24a44176d28168780f1d4b0491a75704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5fe17b69dabd3ba65e8f3aa1900918"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afa5fe17b69dabd3ba65e8f3aa1900918">operator()</a> (const <a class="el" href="namespacecasacore.html#a863dbf26a1e602513158145a3fb71183">LogicalArray</a> &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>) const </td></tr>
<tr class="memdesc:afa5fe17b69dabd3ba65e8f3aa1900918"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array is masked by the input LogicalArray.  <a href="#afa5fe17b69dabd3ba65e8f3aa1900918">More...</a><br/></td></tr>
<tr class="separator:afa5fe17b69dabd3ba65e8f3aa1900918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf1320c902f0de60d00d4ba24a8bc23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aacf1320c902f0de60d00d4ba24a8bc23">operator()</a> (const <a class="el" href="namespacecasacore.html#a863dbf26a1e602513158145a3fb71183">LogicalArray</a> &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>)</td></tr>
<tr class="separator:aacf1320c902f0de60d00d4ba24a8bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b580c8ef2f5d621417db0a0b41757"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a6a0b580c8ef2f5d621417db0a0b41757">operator()</a> (const <a class="el" href="namespacecasacore.html#af8781439f78f62ce1236324ffd1f43c9">MaskedLogicalArray</a> &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>) const </td></tr>
<tr class="memdesc:a6a0b580c8ef2f5d621417db0a0b41757"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array is masked by the input MaskedLogicalArray.  <a href="#a6a0b580c8ef2f5d621417db0a0b41757">More...</a><br/></td></tr>
<tr class="separator:a6a0b580c8ef2f5d621417db0a0b41757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9da620b3a79da1e1f4fd2a7134d11e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af9da620b3a79da1e1f4fd2a7134d11e7">operator()</a> (const <a class="el" href="namespacecasacore.html#af8781439f78f62ce1236324ffd1f43c9">MaskedLogicalArray</a> &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>)</td></tr>
<tr class="separator:af9da620b3a79da1e1f4fd2a7134d11e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6e355925104f2d060be77039c54b07"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0d6e355925104f2d060be77039c54b07">nrefs</a> () const </td></tr>
<tr class="memdesc:a0d6e355925104f2d060be77039c54b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of references the underlying storage has assigned to it.  <a href="#a0d6e355925104f2d060be77039c54b07">More...</a><br/></td></tr>
<tr class="separator:a0d6e355925104f2d060be77039c54b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec06c5462be201b570837d72487c95a4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aec06c5462be201b570837d72487c95a4">ok</a> () const override</td></tr>
<tr class="memdesc:aec06c5462be201b570837d72487c95a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> is consistent.  <a href="#aec06c5462be201b570837d72487c95a4">More...</a><br/></td></tr>
<tr class="separator:aec06c5462be201b570837d72487c95a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0832098b33b80834446a118d904ca0a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0832098b33b80834446a118d904ca0a9">conform</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other) const </td></tr>
<tr class="memdesc:a0832098b33b80834446a118d904ca0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the shapes identical?  <a href="#a0832098b33b80834446a118d904ca0a9">More...</a><br/></td></tr>
<tr class="separator:a0832098b33b80834446a118d904ca0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cace9f275daa415be269cfd56982ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8cace9f275daa415be269cfd56982ff6">conform</a> (const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;other) const </td></tr>
<tr class="separator:a8cace9f275daa415be269cfd56982ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2013c620f25a0c13f8d2c83ccbd0b4"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#adc2013c620f25a0c13f8d2c83ccbd0b4">data</a> ()</td></tr>
<tr class="memdesc:adc2013c620f25a0c13f8d2c83ccbd0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the beginning of the array.  <a href="#adc2013c620f25a0c13f8d2c83ccbd0b4">More...</a><br/></td></tr>
<tr class="separator:adc2013c620f25a0c13f8d2c83ccbd0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7641ce351f0a4a2f191cc92be689dba1"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a7641ce351f0a4a2f191cc92be689dba1">data</a> () const </td></tr>
<tr class="separator:a7641ce351f0a4a2f191cc92be689dba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1617712814c24c6c90b6d06eec147810"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1617712814c24c6c90b6d06eec147810">getStorage</a> (bool &amp;deleteIt)</td></tr>
<tr class="memdesc:a1617712814c24c6c90b6d06eec147810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generally use of this should be shunned, except to use a FORTRAN routine or something similar.  <a href="#a1617712814c24c6c90b6d06eec147810">More...</a><br/></td></tr>
<tr class="separator:a1617712814c24c6c90b6d06eec147810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ad27b462537705555b6ac557c841c2"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a02ad27b462537705555b6ac557c841c2">getStorage</a> (bool &amp;deleteIt) const </td></tr>
<tr class="separator:a02ad27b462537705555b6ac557c841c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0968dbe4c417c9bdba1ce08c5c6e85aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0968dbe4c417c9bdba1ce08c5c6e85aa">getVStorage</a> (bool &amp;deleteIt) override</td></tr>
<tr class="memdesc:a0968dbe4c417c9bdba1ce08c5c6e85aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions behave the same as the corresponding getStorage functions in the derived templated <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class.  <a href="#a0968dbe4c417c9bdba1ce08c5c6e85aa">More...</a><br/></td></tr>
<tr class="separator:a0968dbe4c417c9bdba1ce08c5c6e85aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a030f4a8b208b9fe572ca4b5a605b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa78a030f4a8b208b9fe572ca4b5a605b">getVStorage</a> (bool &amp;deleteIt) const override</td></tr>
<tr class="separator:aa78a030f4a8b208b9fe572ca4b5a605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad2c348ee344355b003622de52c6b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3ad2c348ee344355b003622de52c6b8a">putStorage</a> (T *&amp;storage, bool deleteAndCopy)</td></tr>
<tr class="memdesc:a3ad2c348ee344355b003622de52c6b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Array.html#a3ad2c348ee344355b003622de52c6b8a" title="putStorage() is normally called after a call to getStorage() (cf). ">putStorage()</a> is normally called after a call to <a class="el" href="classcasacore_1_1Array.html#a1617712814c24c6c90b6d06eec147810" title="Generally use of this should be shunned, except to use a FORTRAN routine or something similar...">getStorage()</a> (cf).  <a href="#a3ad2c348ee344355b003622de52c6b8a">More...</a><br/></td></tr>
<tr class="separator:a3ad2c348ee344355b003622de52c6b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bba3e462b2db02178ff5d6535a93736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2bba3e462b2db02178ff5d6535a93736">putVStorage</a> (void *&amp;storage, bool deleteAndCopy) override</td></tr>
<tr class="separator:a2bba3e462b2db02178ff5d6535a93736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab397896c9b7210b9dfedd83fc06fc9ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab397896c9b7210b9dfedd83fc06fc9ca">freeStorage</a> (const T *&amp;storage, bool deleteIt) const </td></tr>
<tr class="memdesc:ab397896c9b7210b9dfedd83fc06fc9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If deleteIt is set, delete "storage".  <a href="#ab397896c9b7210b9dfedd83fc06fc9ca">More...</a><br/></td></tr>
<tr class="separator:ab397896c9b7210b9dfedd83fc06fc9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122115c70a042d16cecf6eb57f3027c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a122115c70a042d16cecf6eb57f3027c8">freeVStorage</a> (const void *&amp;storage, bool deleteIt) const override</td></tr>
<tr class="separator:a122115c70a042d16cecf6eb57f3027c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea57570f88f8fb9e20d768907fde31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a10ea57570f88f8fb9e20d768907fde31">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy=<a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a>, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a10ea57570f88f8fb9e20d768907fde31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the data values with those in the pointer <code>storage</code>.  <a href="#a10ea57570f88f8fb9e20d768907fde31">More...</a><br/></td></tr>
<tr class="separator:a10ea57570f88f8fb9e20d768907fde31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8f5cb8b048189ee68feee3bf78c1f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a7e8f5cb8b048189ee68feee3bf78c1f4">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T *storage, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>=Alloc())</td></tr>
<tr class="memdesc:a7e8f5cb8b048189ee68feee3bf78c1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since the pointer is const, a copy is always taken.  <a href="#a7e8f5cb8b048189ee68feee3bf78c1f4">More...</a><br/></td></tr>
<tr class="separator:a7e8f5cb8b048189ee68feee3bf78c1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8fde8c85eef3bdb1b726881992a845"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classcasacore_1_1ArrayPositionIterator.html">ArrayPositionIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aeb8fde8c85eef3bdb1b726881992a845">makeIterator</a> (size_t byDim) const override</td></tr>
<tr class="memdesc:aeb8fde8c85eef3bdb1b726881992a845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a> object of the correct type.  <a href="#aeb8fde8c85eef3bdb1b726881992a845">More...</a><br/></td></tr>
<tr class="separator:aeb8fde8c85eef3bdb1b726881992a845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac79186dc8903d66e4ae8ee453e935d85"><td class="memItemLeft" align="right" valign="top">Alloc &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a> ()</td></tr>
<tr class="memdesc:ac79186dc8903d66e4ae8ee453e935d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the allocator associated with this array.  <a href="#ac79186dc8903d66e4ae8ee453e935d85">More...</a><br/></td></tr>
<tr class="separator:ac79186dc8903d66e4ae8ee453e935d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff977af3402ce92af4e67a30c2eb59"><td class="memItemLeft" align="right" valign="top">const Alloc &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#abdff977af3402ce92af4e67a30c2eb59">allocator</a> () const </td></tr>
<tr class="separator:abdff977af3402ce92af4e67a30c2eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a64bfcef3a280672fbff97e81986114e7 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a64bfcef3a280672fbff97e81986114e7">ArrayBase</a> () noexcept</td></tr>
<tr class="separator:a64bfcef3a280672fbff97e81986114e7 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a91ed9204473ba8e56c000aec28f897a9">ArrayBase</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>)</td></tr>
<tr class="memdesc:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape, i.e.  <a href="#a91ed9204473ba8e56c000aec28f897a9">More...</a><br/></td></tr>
<tr class="separator:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a30c9620b87a61de748defab245f98407">ArrayBase</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other)</td></tr>
<tr class="memdesc:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a30c9620b87a61de748defab245f98407">More...</a><br/></td></tr>
<tr class="separator:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c406375f8b065beec9bed16d8e0e32 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a91c406375f8b065beec9bed16d8e0e32">ArrayBase</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&amp;source) noexcept</td></tr>
<tr class="separator:a91c406375f8b065beec9bed16d8e0e32 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb3a570b036cfd40ad1aec74f705dea inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a2eb3a570b036cfd40ad1aec74f705dea">assign</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;)</td></tr>
<tr class="memdesc:a2eb3a570b036cfd40ad1aec74f705dea inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#a2eb3a570b036cfd40ad1aec74f705dea">More...</a><br/></td></tr>
<tr class="separator:a2eb3a570b036cfd40ad1aec74f705dea inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e395a4de526d462b8dbff44c956c6 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a5e4e395a4de526d462b8dbff44c956c6">operator=</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;)=delete</td></tr>
<tr class="separator:a5e4e395a4de526d462b8dbff44c956c6 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eef8fb1291d0adeed058b634bde4dd inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a96eef8fb1291d0adeed058b634bde4dd">operator=</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a96eef8fb1291d0adeed058b634bde4dd inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aebca2b56f9384dad80430808678ed3 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a2aebca2b56f9384dad80430808678ed3">~ArrayBase</a> () noexcept</td></tr>
<tr class="memdesc:a2aebca2b56f9384dad80430808678ed3 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2aebca2b56f9384dad80430808678ed3">More...</a><br/></td></tr>
<tr class="separator:a2aebca2b56f9384dad80430808678ed3 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1f0f191c04922842b13fdef745f75a inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a3a1f0f191c04922842b13fdef745f75a">ndim</a> () const </td></tr>
<tr class="memdesc:a3a1f0f191c04922842b13fdef745f75a inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality of this array.  <a href="#a3a1f0f191c04922842b13fdef745f75a">More...</a><br/></td></tr>
<tr class="separator:a3a1f0f191c04922842b13fdef745f75a inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a9c59e870964872ddfeb2de91e05d8b55">nelements</a> () const </td></tr>
<tr class="memdesc:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many elements does this array have? Product of all axis lengths.  <a href="#a9c59e870964872ddfeb2de91e05d8b55">More...</a><br/></td></tr>
<tr class="separator:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7934dab73a7952f9fbfb7a887efbe34 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad7934dab73a7952f9fbfb7a887efbe34">size</a> () const </td></tr>
<tr class="separator:ad7934dab73a7952f9fbfb7a887efbe34 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69856e95234723374c7663d45038533 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aa69856e95234723374c7663d45038533">empty</a> () const </td></tr>
<tr class="memdesc:aa69856e95234723374c7663d45038533 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the array empty (i.e.  <a href="#aa69856e95234723374c7663d45038533">More...</a><br/></td></tr>
<tr class="separator:aa69856e95234723374c7663d45038533 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355bb8b4ad8fb10ca3ae5695e4292b19 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a355bb8b4ad8fb10ca3ae5695e4292b19">contiguousStorage</a> () const </td></tr>
<tr class="memdesc:a355bb8b4ad8fb10ca3ae5695e4292b19 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the array data contiguous? If they are not contiguous, <code>getStorage</code> (see below) needs to make a copy.  <a href="#a355bb8b4ad8fb10ca3ae5695e4292b19">More...</a><br/></td></tr>
<tr class="separator:a355bb8b4ad8fb10ca3ae5695e4292b19 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a> () const </td></tr>
<tr class="memdesc:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of each axis.  <a href="#aaddb725358b52d576969897b1e0ef83d">More...</a><br/></td></tr>
<tr class="separator:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aa621866a6785c8a91882b2ee5a2c2e94">endPosition</a> () const </td></tr>
<tr class="memdesc:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function: endPosition(i) = shape(i) - 1; i.e.  <a href="#aa621866a6785c8a91882b2ee5a2c2e94">More...</a><br/></td></tr>
<tr class="separator:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a034eb01e79cde1251f17aed40ccfcb45">steps</a> () const </td></tr>
<tr class="memdesc:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return steps to be made if stepping one element in a dimension.  <a href="#a034eb01e79cde1251f17aed40ccfcb45">More...</a><br/></td></tr>
<tr class="separator:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8459916b0a53b73f16ca03298d752888">validateConformance</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;) const </td></tr>
<tr class="memdesc:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various helper functions.  <a href="#a8459916b0a53b73f16ca03298d752888">More...</a><br/></td></tr>
<tr class="separator:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d800f4b3f4d48e4735146fbf5881a8 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a15d800f4b3f4d48e4735146fbf5881a8">validateIndex</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;) const </td></tr>
<tr class="separator:a15d800f4b3f4d48e4735146fbf5881a8 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2266eea1f56f951f0f5e84d11adce485 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a2266eea1f56f951f0f5e84d11adce485">validateIndex</a> (size_t index) const </td></tr>
<tr class="separator:a2266eea1f56f951f0f5e84d11adce485 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a5bae163ad087b1c7e3c907d2d7e99 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aa4a5bae163ad087b1c7e3c907d2d7e99">validateIndex</a> (size_t index1, size_t index2) const </td></tr>
<tr class="separator:aa4a5bae163ad087b1c7e3c907d2d7e99 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f5388c7b34cbecbfe69e76470d69e7 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a70f5388c7b34cbecbfe69e76470d69e7">validateIndex</a> (size_t index1, size_t index2, size_t index3) const </td></tr>
<tr class="separator:a70f5388c7b34cbecbfe69e76470d69e7 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5472f2655dfa4a2d3488bfb4cd3dfef1"><td class="memItemLeft" align="right" valign="top">static struct <br class="typebreak"/>
<a class="el" href="structcasacore_1_1Array_1_1uninitializedType.html">casacore::Array::uninitializedType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5472f2655dfa4a2d3488bfb4cd3dfef1">uninitialized</a></td></tr>
<tr class="separator:a5472f2655dfa4a2d3488bfb4cd3dfef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af6654744bfc7454d925e62cf3c8a58c3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af6654744bfc7454d925e62cf3c8a58c3">ArrayIterator&lt; T, Alloc &gt;</a></td></tr>
<tr class="memdesc:af6654744bfc7454d925e62cf3c8a58c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through Arrays.  <a href="#af6654744bfc7454d925e62cf3c8a58c3">More...</a><br/></td></tr>
<tr class="separator:af6654744bfc7454d925e62cf3c8a58c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bd95421382e1a957b1a3de4a23f916"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a22bd95421382e1a957b1a3de4a23f916">allocator_type</a></td></tr>
<tr class="memdesc:a22bd95421382e1a957b1a3de4a23f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the STL-style iterator functions (only forward iterator).  <a href="#a22bd95421382e1a957b1a3de4a23f916">More...</a><br/></td></tr>
<tr class="separator:a22bd95421382e1a957b1a3de4a23f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a844b952a3b81304116d54247803d7"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a94a844b952a3b81304116d54247803d7">value_type</a></td></tr>
<tr class="memdesc:a94a844b952a3b81304116d54247803d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type.  <a href="#a94a844b952a3b81304116d54247803d7">More...</a><br/></td></tr>
<tr class="separator:a94a844b952a3b81304116d54247803d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11f0fedad5b0a0b1cc106f55f8281ab"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab11f0fedad5b0a0b1cc106f55f8281ab">const_reference</a></td></tr>
<tr class="memdesc:ab11f0fedad5b0a0b1cc106f55f8281ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO This is how std containers define a reference type, but the name 'reference' is already taken by a method.  <a href="#ab11f0fedad5b0a0b1cc106f55f8281ab">More...</a><br/></td></tr>
<tr class="separator:ab11f0fedad5b0a0b1cc106f55f8281ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1f5ac3ced4b20384937f9faad878c2"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8c1f5ac3ced4b20384937f9faad878c2">pointer</a></td></tr>
<tr class="memdesc:a8c1f5ac3ced4b20384937f9faad878c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an element type.  <a href="#a8c1f5ac3ced4b20384937f9faad878c2">More...</a><br/></td></tr>
<tr class="separator:a8c1f5ac3ced4b20384937f9faad878c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc71b909d594972a7847b5845f3201"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac1bc71b909d594972a7847b5845f3201">const_pointer</a></td></tr>
<tr class="memdesc:ac1bc71b909d594972a7847b5845f3201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant pointer to the element type.  <a href="#ac1bc71b909d594972a7847b5845f3201">More...</a><br/></td></tr>
<tr class="separator:ac1bc71b909d594972a7847b5845f3201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f12e1e3b18673abb4015df5da8d34a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a></td></tr>
<tr class="separator:a7f12e1e3b18673abb4015df5da8d34a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb9b461ba061c6e7ab101cf9a84ce03"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a></td></tr>
<tr class="separator:afeb9b461ba061c6e7ab101cf9a84ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4139ce998a084a34603d0021b8e933dc"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a></td></tr>
<tr class="separator:a4139ce998a084a34603d0021b8e933dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43f921a530a6422e69826f950db8de9"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a></td></tr>
<tr class="separator:ac43f921a530a6422e69826f950db8de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632a4c3d541a4d5b70d2d0d31718396"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename SAlloc &gt; </td></tr>
<tr class="memitem:a0632a4c3d541a4d5b70d2d0d31718396"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0632a4c3d541a4d5b70d2d0d31718396">swap</a> (<a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; ST, SAlloc &gt; &amp;left, <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; ST, SAlloc &gt; &amp;right)</td></tr>
<tr class="separator:a0632a4c3d541a4d5b70d2d0d31718396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde725345f50f662f6ce43cb481472d2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classcasacore_1_1arrays__internal_1_1Storage.html">arrays_internal::Storage</a>&lt; T, <br class="typebreak"/>
Alloc &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#adde725345f50f662f6ce43cb481472d2">data_p</a></td></tr>
<tr class="memdesc:adde725345f50f662f6ce43cb481472d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a Storage that contains the data.  <a href="#adde725345f50f662f6ce43cb481472d2">More...</a><br/></td></tr>
<tr class="separator:adde725345f50f662f6ce43cb481472d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1cd5edd8bc4f4eccbcd285c733ab75"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9d1cd5edd8bc4f4eccbcd285c733ab75">begin_p</a></td></tr>
<tr class="memdesc:a9d1cd5edd8bc4f4eccbcd285c733ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pointer is adjusted to point to the first element of the array.  <a href="#a9d1cd5edd8bc4f4eccbcd285c733ab75">More...</a><br/></td></tr>
<tr class="separator:a9d1cd5edd8bc4f4eccbcd285c733ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63148535b1255ae64669243e997a2c9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac63148535b1255ae64669243e997a2c9">end_p</a></td></tr>
<tr class="memdesc:ac63148535b1255ae64669243e997a2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The end for an STL-style iteration.  <a href="#ac63148535b1255ae64669243e997a2c9">More...</a><br/></td></tr>
<tr class="separator:ac63148535b1255ae64669243e997a2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f0eaa446f7521324798154d94845a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab04f0eaa446f7521324798154d94845a">begin</a> ()</td></tr>
<tr class="memdesc:ab04f0eaa446f7521324798154d94845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator object for any array.  <a href="#ab04f0eaa446f7521324798154d94845a">More...</a><br/></td></tr>
<tr class="separator:ab04f0eaa446f7521324798154d94845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d952e655170243bd5da55454e854c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8d952e655170243bd5da55454e854c45">begin</a> () const </td></tr>
<tr class="separator:a8d952e655170243bd5da55454e854c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee82e2e53970cbcfa50a98ee0f7b5d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end</a> ()</td></tr>
<tr class="separator:aee82e2e53970cbcfa50a98ee0f7b5d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc19caa1de2d3ffbe09a7ff172260b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#abc19caa1de2d3ffbe09a7ff172260b4b">end</a> () const </td></tr>
<tr class="separator:abc19caa1de2d3ffbe09a7ff172260b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90899c5364c890df123884a6c51b2724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a90899c5364c890df123884a6c51b2724">cbegin</a> ()</td></tr>
<tr class="memdesc:a90899c5364c890df123884a6c51b2724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator object for a contiguous array.  <a href="#a90899c5364c890df123884a6c51b2724">More...</a><br/></td></tr>
<tr class="separator:a90899c5364c890df123884a6c51b2724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f490d3ec79daba7d1f42e0fde2f3d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1f490d3ec79daba7d1f42e0fde2f3d3d">cbegin</a> () const </td></tr>
<tr class="separator:a1f490d3ec79daba7d1f42e0fde2f3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b9d96e42e169877d1080413e143ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa9b9d96e42e169877d1080413e143ce3">cend</a> ()</td></tr>
<tr class="separator:aa9b9d96e42e169877d1080413e143ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626881128eefa0b3d3a46b6395c8057c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a626881128eefa0b3d3a46b6395c8057c">cend</a> () const </td></tr>
<tr class="separator:a626881128eefa0b3d3a46b6395c8057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba0e6c88766f0cb65c46ae0ab5cd049"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a3ba0e6c88766f0cb65c46ae0ab5cd049"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3ba0e6c88766f0cb65c46ae0ab5cd049">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, Integral startIter, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>, std::true_type)</td></tr>
<tr class="memdesc:a3ba0e6c88766f0cb65c46ae0ab5cd049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of constructor taking a Shape, a Templated parameter and an allocator.  <a href="#a3ba0e6c88766f0cb65c46ae0ab5cd049">More...</a><br/></td></tr>
<tr class="separator:a3ba0e6c88766f0cb65c46ae0ab5cd049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70c4c66781cced971bca93fef2d9371"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab70c4c66781cced971bca93fef2d9371"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab70c4c66781cced971bca93fef2d9371">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, InputIterator startIter, const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>, std::false_type)</td></tr>
<tr class="memdesc:ab70c4c66781cced971bca93fef2d9371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of constructor taking a Shape, a Templated parameter and an allocator.  <a href="#ab70c4c66781cced971bca93fef2d9371">More...</a><br/></td></tr>
<tr class="separator:ab70c4c66781cced971bca93fef2d9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bae13da621865b64175890d1721b4e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5bae13da621865b64175890d1721b4e0">copy</a> (const Alloc &amp;<a class="el" href="classcasacore_1_1Array.html#ac79186dc8903d66e4ae8ee453e935d85">allocator</a>) const </td></tr>
<tr class="memdesc:a5bae13da621865b64175890d1721b4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy using the allocator.  <a href="#a5bae13da621865b64175890d1721b4e0">More...</a><br/></td></tr>
<tr class="separator:a5bae13da621865b64175890d1721b4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74bdbf007cf10bcb37c6c745c87d575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab74bdbf007cf10bcb37c6c745c87d575">assign_conforming_implementation</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other, std::true_type)</td></tr>
<tr class="memdesc:ab74bdbf007cf10bcb37c6c745c87d575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for assign for copyable types.  <a href="#ab74bdbf007cf10bcb37c6c745c87d575">More...</a><br/></td></tr>
<tr class="separator:ab74bdbf007cf10bcb37c6c745c87d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b521311b3114b94b8728358582bc0e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3b521311b3114b94b8728358582bc0e3">assign_conforming_implementation</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;, std::false_type)</td></tr>
<tr class="memdesc:a3b521311b3114b94b8728358582bc0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for assign for non-copyable types: can not be assigned.  <a href="#a3b521311b3114b94b8728358582bc0e3">More...</a><br/></td></tr>
<tr class="separator:a3b521311b3114b94b8728358582bc0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba45faf8cc4a05311fd12336e3e7dcaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aba45faf8cc4a05311fd12336e3e7dcaf">isUnique</a> () const </td></tr>
<tr class="memdesc:aba45faf8cc4a05311fd12336e3e7dcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> is unique when the container is shared and when nrefs==1.  <a href="#aba45faf8cc4a05311fd12336e3e7dcaf">More...</a><br/></td></tr>
<tr class="separator:aba45faf8cc4a05311fd12336e3e7dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce8ca72e424546c3760e087ee13a1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ae1ce8ca72e424546c3760e087ee13a1b">copyToContiguousStorage</a> (T *dst, <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;src, std::true_type)</td></tr>
<tr class="separator:ae1ce8ca72e424546c3760e087ee13a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95005c07e1dcb87d7781198780da3ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad95005c07e1dcb87d7781198780da3ff">copyToContiguousStorage</a> (T *, <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;, std::false_type)</td></tr>
<tr class="separator:ad95005c07e1dcb87d7781198780da3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e4e4404761b227244f1fec84f3ef58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a82e4e4404761b227244f1fec84f3ef58">Array</a> (<a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;source, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;shapeForSource) noexcept</td></tr>
<tr class="memdesc:a82e4e4404761b227244f1fec84f3ef58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source will be empty with given shape after this call.  <a href="#a82e4e4404761b227244f1fec84f3ef58">More...</a><br/></td></tr>
<tr class="separator:a82e4e4404761b227244f1fec84f3ef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9177dcb603e10c263dedc6caa446cf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9177dcb603e10c263dedc6caa446cf37">swap</a> (<a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:a9177dcb603e10c263dedc6caa446cf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this array with another array.  <a href="#a9177dcb603e10c263dedc6caa446cf37">More...</a><br/></td></tr>
<tr class="separator:a9177dcb603e10c263dedc6caa446cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f125ce318a3cc2d680d20d4a590c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ae39f125ce318a3cc2d680d20d4a590c1">preTakeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;)</td></tr>
<tr class="memdesc:ae39f125ce318a3cc2d680d20d4a590c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre/post processing hook of <a class="el" href="classcasacore_1_1Array.html#a10ea57570f88f8fb9e20d768907fde31" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> for subclasses.  <a href="#ae39f125ce318a3cc2d680d20d4a590c1">More...</a><br/></td></tr>
<tr class="separator:ae39f125ce318a3cc2d680d20d4a590c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672d9c912bee9f97f2f9eb1a75d8155c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a672d9c912bee9f97f2f9eb1a75d8155c">postTakeStorage</a> ()</td></tr>
<tr class="separator:a672d9c912bee9f97f2f9eb1a75d8155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9e8c71a1acb55eb7883b017841c2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2d9e8c71a1acb55eb7883b017841c2f3">checkBeforeResize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape)</td></tr>
<tr class="memdesc:a2d9e8c71a1acb55eb7883b017841c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when this array is about to be resized, before any work is done.  <a href="#a2d9e8c71a1acb55eb7883b017841c2f3">More...</a><br/></td></tr>
<tr class="separator:a2d9e8c71a1acb55eb7883b017841c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20db28372032d34e7d02950785fdb2d2"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a20db28372032d34e7d02950785fdb2d2">fixedDimensionality</a> () const </td></tr>
<tr class="memdesc:a20db28372032d34e7d02950785fdb2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses can return their dimensionality.  <a href="#a20db28372032d34e7d02950785fdb2d2">More...</a><br/></td></tr>
<tr class="separator:a20db28372032d34e7d02950785fdb2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980e14d9671c994a2b8104bfd6a00ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac980e14d9671c994a2b8104bfd6a00ef">checkAssignableType</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;arrayBase) const </td></tr>
<tr class="separator:ac980e14d9671c994a2b8104bfd6a00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad723c59e8cda0157a1e62ec2366eb74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aad723c59e8cda0157a1e62ec2366eb74">doNonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="memdesc:aad723c59e8cda0157a1e62ec2366eb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object.  <a href="#aad723c59e8cda0157a1e62ec2366eb74">More...</a><br/></td></tr>
<tr class="separator:aad723c59e8cda0157a1e62ec2366eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8a8c1463075a1f46694364d038f694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aeb8a8c1463075a1f46694364d038f694">makeSteps</a> ()</td></tr>
<tr class="memdesc:aeb8a8c1463075a1f46694364d038f694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the steps and the end for a derived class.  <a href="#aeb8a8c1463075a1f46694364d038f694">More...</a><br/></td></tr>
<tr class="separator:aeb8a8c1463075a1f46694364d038f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3e85bc4786177805789fd5ca6785b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#acc3e85bc4786177805789fd5ca6785b8">setEndIter</a> ()</td></tr>
<tr class="memdesc:acc3e85bc4786177805789fd5ca6785b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end iterator.  <a href="#acc3e85bc4786177805789fd5ca6785b8">More...</a><br/></td></tr>
<tr class="separator:acc3e85bc4786177805789fd5ca6785b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca91898e7d439ce98604d0cc3181506"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4ca91898e7d439ce98604d0cc3181506">copyToContiguousStorage</a> (T *dst, <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;src)</td></tr>
<tr class="separator:a4ca91898e7d439ce98604d0cc3181506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a0f47e6343d3fc033f46e0e0f2f53e854 inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a0f47e6343d3fc033f46e0e0f2f53e854">arrayVersion</a> ()</td></tr>
<tr class="memdesc:a0f47e6343d3fc033f46e0e0f2f53e854 inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> version for major change (used by ArrayIO).  <a href="#a0f47e6343d3fc033f46e0e0f2f53e854">More...</a><br/></td></tr>
<tr class="separator:a0f47e6343d3fc033f46e0e0f2f53e854 inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a3454e95efccfe3459a5c762e0334d8a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a3454e95efccfe3459a5c762e0334d8a2">ArrayBase</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&amp;source, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;shapeForSource) noexcept</td></tr>
<tr class="memdesc:a3454e95efccfe3459a5c762e0334d8a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">For subclasses, this move constructor allows the moved-from object to
</pre><p> obtain a given shape after resizing.  <a href="#a3454e95efccfe3459a5c762e0334d8a2">More...</a><br/></td></tr>
<tr class="separator:a3454e95efccfe3459a5c762e0334d8a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53752abbc58307ad2a997d3e2c577e9f inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a53752abbc58307ad2a997d3e2c577e9f">swap</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;source) noexcept</td></tr>
<tr class="separator:a53752abbc58307ad2a997d3e2c577e9f inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa234412772be1fa6c37f1240760f04cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aa234412772be1fa6c37f1240760f04cf">reformOrResize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, bool resizeIfNeeded, size_t nReferences, long long nElementsAllocated, bool copyDataIfNeeded, size_t resizePercentage)</td></tr>
<tr class="memdesc:aa234412772be1fa6c37f1240760f04cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either reforms the array if size permits or resizes it to the new shape.  <a href="#aa234412772be1fa6c37f1240760f04cf">More...</a><br/></td></tr>
<tr class="separator:aa234412772be1fa6c37f1240760f04cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dbc8ec67c51c8424c6cc1d51cc3272 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a93dbc8ec67c51c8424c6cc1d51cc3272">isStorageContiguous</a> () const </td></tr>
<tr class="memdesc:a93dbc8ec67c51c8424c6cc1d51cc3272 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the storage of a subset is contiguous.  <a href="#a93dbc8ec67c51c8424c6cc1d51cc3272">More...</a><br/></td></tr>
<tr class="separator:a93dbc8ec67c51c8424c6cc1d51cc3272 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ac41a8e183c0ab44b35b3cccf5ba344a2">checkVectorShape</a> ()</td></tr>
<tr class="memdesc:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a vector is correct.  <a href="#ac41a8e183c0ab44b35b3cccf5ba344a2">More...</a><br/></td></tr>
<tr class="separator:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a2ff72758e9d4bc7a349784896aa0764e">checkMatrixShape</a> ()</td></tr>
<tr class="memdesc:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a matrix is correct.  <a href="#a2ff72758e9d4bc7a349784896aa0764e">More...</a><br/></td></tr>
<tr class="separator:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#af2c82bc4afae2c73a2ccc962f88059c0">checkCubeShape</a> ()</td></tr>
<tr class="memdesc:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a cube is correct.  <a href="#af2c82bc4afae2c73a2ccc962f88059c0">More...</a><br/></td></tr>
<tr class="separator:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6da66ac38afffe5c1dcd70ea888dc8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aee6da66ac38afffe5c1dcd70ea888dc8">baseReform</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;tmp, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, bool strict=true) const </td></tr>
<tr class="memdesc:aee6da66ac38afffe5c1dcd70ea888dc8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reform the array to a shape with the same nr of elements.  <a href="#aee6da66ac38afffe5c1dcd70ea888dc8">More...</a><br/></td></tr>
<tr class="separator:aee6da66ac38afffe5c1dcd70ea888dc8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a1ff75013c8d149ee61e682be1d47e173">baseNonDegenerate</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="memdesc:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object.  <a href="#a1ff75013c8d149ee61e682be1d47e173">More...</a><br/></td></tr>
<tr class="separator:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d67fa669db04596d96f5256ca22f56a inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a7d67fa669db04596d96f5256ca22f56a">baseAddDegenerate</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;, size_t numAxes)</td></tr>
<tr class="memdesc:a7d67fa669db04596d96f5256ca22f56a inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">These member functions return an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>.  <a href="#a7d67fa669db04596d96f5256ca22f56a">More...</a><br/></td></tr>
<tr class="separator:a7d67fa669db04596d96f5256ca22f56a inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a74ecf3661363376aa05c0bcb585b51cf">makeSubset</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;out, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;b, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;e, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;i)</td></tr>
<tr class="memdesc:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a subset of an array.  <a href="#a74ecf3661363376aa05c0bcb585b51cf">More...</a><br/></td></tr>
<tr class="separator:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff01903adce877d71aefd8be11298c8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#abff01903adce877d71aefd8be11298c8">makeDiagonal</a> (size_t firstAxis, long long diag)</td></tr>
<tr class="memdesc:abff01903adce877d71aefd8be11298c8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length and stride such that the diagonal of the matrices defined by two consecutive axes is formed.  <a href="#abff01903adce877d71aefd8be11298c8">More...</a><br/></td></tr>
<tr class="separator:abff01903adce877d71aefd8be11298c8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530d2de6542a0207d24459cacbe6a938 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a530d2de6542a0207d24459cacbe6a938">conform2</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other) const </td></tr>
<tr class="memdesc:a530d2de6542a0207d24459cacbe6a938 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the shapes identical?  <a href="#a530d2de6542a0207d24459cacbe6a938">More...</a><br/></td></tr>
<tr class="separator:a530d2de6542a0207d24459cacbe6a938 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8c41931c3a6b36e65daf32efbc145e36">baseMakeSteps</a> ()</td></tr>
<tr class="memdesc:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the indexing step sizes.  <a href="#a8c41931c3a6b36e65daf32efbc145e36">More...</a><br/></td></tr>
<tr class="separator:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aed382ddf851b7e18a5d94e8c34b52 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a27aed382ddf851b7e18a5d94e8c34b52">copyVectorHelper</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other)</td></tr>
<tr class="memdesc:a27aed382ddf851b7e18a5d94e8c34b52 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for templated <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a> class.  <a href="#a27aed382ddf851b7e18a5d94e8c34b52">More...</a><br/></td></tr>
<tr class="separator:a27aed382ddf851b7e18a5d94e8c34b52 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a4d5272ad5674505e20d8945acfe9c666">nels_p</a></td></tr>
<tr class="memdesc:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the array.  <a href="#a4d5272ad5674505e20d8945acfe9c666">More...</a><br/></td></tr>
<tr class="separator:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad07fdbd04830846d9847e3ea32e620 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a7ad07fdbd04830846d9847e3ea32e620">ndimen_p</a></td></tr>
<tr class="memdesc:a7ad07fdbd04830846d9847e3ea32e620 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensionality of the array.  <a href="#a7ad07fdbd04830846d9847e3ea32e620">More...</a><br/></td></tr>
<tr class="separator:a7ad07fdbd04830846d9847e3ea32e620 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb4791a0a456441f19d97c36ce836b1 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a7bb4791a0a456441f19d97c36ce836b1">contiguous_p</a></td></tr>
<tr class="memdesc:a7bb4791a0a456441f19d97c36ce836b1 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the data contiguous?  <a href="#a7bb4791a0a456441f19d97c36ce836b1">More...</a><br/></td></tr>
<tr class="separator:a7bb4791a0a456441f19d97c36ce836b1 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ab1d08aacff0367d78e33b4d9137e8527">length_p</a></td></tr>
<tr class="memdesc:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to hold the shape, increment into the underlying storage and originalLength of the array.  <a href="#ab1d08aacff0367d78e33b4d9137e8527">More...</a><br/></td></tr>
<tr class="separator:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5bbd97070fc1e0c5f5a5596c247b0 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a83d5bbd97070fc1e0c5f5a5596c247b0">inc_p</a></td></tr>
<tr class="separator:a83d5bbd97070fc1e0c5f5a5596c247b0 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195fae04c02bad814a4a352747c1ead inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8195fae04c02bad814a4a352747c1ead">originalLength_p</a></td></tr>
<tr class="separator:a8195fae04c02bad814a4a352747c1ead inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad19b3969a0875a2ead7c4611de6b2d4f">steps_p</a></td></tr>
<tr class="memdesc:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to hold the step to next element in each dimension.  <a href="#ad19b3969a0875a2ead7c4611de6b2d4f">More...</a><br/></td></tr>
<tr class="separator:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc&gt;<br/>
class casacore::Array&lt; T, Alloc &gt;</h3>

<p>A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class is the base class for the <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, and <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a> subclasses. </p>
<p><a class="anchor" id="Array_summary"></a> Indexing into the array, and positions in general, are given with <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> (essentially a vector of integers) objects. That is, an N-dimensional array requires a length-N <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> to define a position within the array. Unlike <a class="el" href="namespacecasacore_1_1C.html">C</a>, indexing is done with (), not []. Also, the storage order is the same as in FORTRAN, i.e. memory varies most rapidly with the first index. </p>
<div class="fragment"><div class="line"><span class="comment">// axisLengths = [1,2,3,4,5]</span></div>
<div class="line">IPosition axisLengths(5, 1, 2, 3, 4, 5); </div>
<div class="line">Array&lt;int&gt; ai(axisLengths);         <span class="comment">// ai is a 5 dimensional array of</span></div>
<div class="line"><span class="comment">// integers; indices are 0-based</span></div>
<div class="line"><span class="comment">// =&gt; ai.nelements() == 120</span></div>
<div class="line">Array&lt;int&gt; ai2(axisLengths);        <span class="comment">// The first element is at index 0</span></div>
<div class="line">IPosition zero(5); zero = 0;        <span class="comment">// [0,0,0,0,0]</span></div>
<div class="line"><span class="comment">//..\.</span></div>
</div><!-- fragment --><p> Indexing into an N-dimensional array is relatively expensive. Normally you will index into a <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, or <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a>. These may be obtained from an N-dimensional array by creating a reference, or by using an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a>. The "shape" of the array is an <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> which gives the length of each axis.</p>
<p>An <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> may be standalone, or it may refer to another array, or to part of another array (by refer we mean that if you change a pixel in the current array, a pixel in the referred to array also changes, i.e. they share underlying storage). <br/>
<b>Warning:</b><em> One way one array can reference another is through the copy constructor; While this might be what you want, you should probably use the <a class="el" href="classcasacore_1_1Array.html#a115142801f497760a6859622ec4ea25b" title="After invocation, this array and other reference the same storage. ">reference()</a> member function to make it explicit; The copy constructor is used when arguments are passed by value; normally functions should not pass Arrays by value, rather they should pass a reference or a const reference; On the positive side, returning an array from a function is efficient since no copying need be done; </em><br/>
</p>
<p>Aside from the explicit <a class="el" href="classcasacore_1_1Array.html#a115142801f497760a6859622ec4ea25b" title="After invocation, this array and other reference the same storage. ">reference()</a> member function, a user will most commonly encounter an array which references another array when he takes an array slice (or section). A slice is a sub-region of an array (which might also have a stride: every nth row, every mth column, ...). </p>
<div class="fragment"><div class="line">IPosition lengths(3,10,20,30);</div>
<div class="line">Array&lt;int&gt; ai(lengths);         <span class="comment">// A 10x20x30 cube</span></div>
<div class="line">Cube&lt;int&gt; ci;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">ci.reference(ai1);              <span class="comment">// ci and ai now reference the same</span></div>
<div class="line"><span class="comment">// storage</span></div>
<div class="line">ci(0,0,0) = 123;                <span class="comment">// Can use Cube indexing</span></div>
<div class="line">ci.xyPlane(2) = 0;              <span class="comment">//     and other member functions</span></div>
<div class="line">IPosition zero(3,0,0,0);</div>
<div class="line">assert(ai(zero) == 123);        <span class="comment">// true because ai, ci are references</span></div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">Array&lt;int&gt; subArray;</div>
<div class="line">IPosition blc(3,0,0,0), trc(3,5,5,5);</div>
<div class="line">subArray.reference(ai(blc, trc));</div>
<div class="line">subArray = 10;                  <span class="comment">// All of subArray, which is the</span></div>
<div class="line"><span class="comment">// subcube from 0,0,0 to 5,5,5 in</span></div>
<div class="line"><span class="comment">// ai, has the value 10.</span></div>
</div><!-- fragment --><p> While the last example has an array slice referenced explicitly by another array variable, normally the user will often only use the slice as a temporary in an expresion, for example: </p>
<div class="fragment"><div class="line">Array&lt;Complex&gt; <a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>;</div>
<div class="line">IPosition blc, trc, offset;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line"><span class="comment">// Copy from one region of the array into another</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>(blc, trc) = <a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>(blc+offset, trc+offset);</div>
</div><!-- fragment --><p>The <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> classes are intended to operate on relatively large amounts of data. While they haven't been extensively tuned yet, they are relatively efficient in terms of speed. Presently they are not space efficient &ndash; the overhead is about 15 words. While this will be improved (probably to about 1/2 that), these array classes are not appropriate for very large numbers of very small arrays. The Block&lt;T&gt; class may be what you want in this circumstance.</p>
<p>Element by element mathematical and logical operations are available for arrays (defined in aips/ArrayMath.h and aips/ArrayLogical.h). Because arithmetic and logical functions are split out, it is possible to create an Array&lt;T, Alloc&gt; (and hence <a class="el" href="classcasacore_1_1Vector.html">Vector&lt;T&gt;</a> etc) for any type T that has a default constructor, assignment operator, and copy constructor. In particular, Array&lt;String&gt; works.</p>
<p>If compiled with the preprocessor symbol AIPS_DEBUG symbol, array consistency ("invariants") will be checked in most member functions, and indexing will be range-checked. This should not be defined for production runs.</p>
<p><br/>
<b>Tip:</b><em> Most of the data members and functions which are "protected" should likely become "private"; </em><br/>
</p>
<h3>To Do</h3>
<ul>
<li>
Integrate into the <a class="el" href="classcasacore_1_1Lattice.html" title="A templated, abstract base class for array-like objects. ">Lattice</a> hierarchy </li>
<li>
Factor out the common functions (shape etc) into a type-independent base class. </li>
</ul>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00156">156</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a22bd95421382e1a957b1a3de4a23f916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#a22bd95421382e1a957b1a3de4a23f916">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the STL-style iterator functions (only forward iterator). </p>
<p>It makes it possible to iterate through all data elements of an array and to use it common STL functions. The <a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end()</a> function is relatively expensive, so it should not be used inside a for statement. It is much better to call it beforehand as shown in the example below. Furthermore it is very important to use <code>++iter</code>, because <code>iter++</code> is 4 times slower. </p>
<div class="fragment"><div class="line">Array&lt;int&gt; arr(shape);</div>
<div class="line">Array&lt;int&gt;::iterator iterend(arr.end());</div>
<div class="line"><span class="keywordflow">for</span> (Array&lt;int&gt;::iterator iter=arr.begin(); iter!=iterend; ++iter) {</div>
<div class="line">*iter += 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class supports random access, so in principle a random iterator could be implemented, but its performance would not be great, especially for non-contiguous arrays. <br/>
Some other STL like functions exist for performance reasons. If the array is contiguous, it is possible to use the <code>cbegin</code> and <code>cend</code> functions which are about 10% faster. <a class="anchor" id="Array_iterator-typedefs"></a> STL-style typedefs.</p>
<p>Type of allocator used to allocate and deallocate space </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00841">841</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac43f921a530a6422e69826f950db8de9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00855">855</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="afeb9b461ba061c6e7ab101cf9a84ce03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00853">853</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1bc71b909d594972a7847b5845f3201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#ac1bc71b909d594972a7847b5845f3201">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant pointer to the element type. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00851">851</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab11f0fedad5b0a0b1cc106f55f8281ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#ab11f0fedad5b0a0b1cc106f55f8281ab">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO This is how std containers define a reference type, but the name 'reference' is already taken by a method. </p>
<p>typedef T&amp; reference; </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00847">847</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4139ce998a084a34603d0021b8e933dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00854">854</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f12e1e3b18673abb4015df5da8d34a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00852">852</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8c1f5ac3ced4b20384937f9faad878c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#a8c1f5ac3ced4b20384937f9faad878c2">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to an element type. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00849">849</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a94a844b952a3b81304116d54247803d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html#a94a844b952a3b81304116d54247803d7">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00843">843</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4da33780a9006dbbac0c73c855d56265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result has dimensionality of zero, and nelements is zero. </p>

</div>
</div>
<a class="anchor" id="ac209b130227b7f50cf7292bcb843d808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an array of the given shape, i.e. </p>
<p>after construction <a class="el" href="namespacecasacore.html#a2eb958ed449eb76058df916fa5e3d7e1" title="1-argument function to get the dimensionality of a lattice. ">array.ndim()</a> == <a class="el" href="namespacecasacore.html#adfd652c4018497747cfa235c8fa22bba" title="1-argument function to get the number of elements in a lattice. ">shape.nelements()</a> and <a class="el" href="namespacecasacore.html#a6c80d55c1617e8540e006c12e3dc990c" title="Function operating on any scalar or array resulting in a Double array containing the shape...">array.shape()</a> == shape. The origin of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> is zero. Storage is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. Without initPolicy parameter, the initialization of elements depends on type <code>T</code>. When <code>T</code> is a fundamental type like <code>int</code>, elements are NOT initialized. When <code>T</code> is a class type like <code>casacore::Complex</code> or <code>std::string</code>, elements are initialized. This inconsistent behavior confuses programmers and make it hard to write efficient and generic code using template. Especially when <code>T</code> is of type <code>Complex</code> or <code>DComplex</code> and it is unnecessary to initialize, provide initPolicy with value <code>NO_INIT</code> to skip the initialization. Therefore, it is strongly recommended to explicitly provide initPolicy parameter, </p>

</div>
</div>
<a class="anchor" id="aa71eebceb6e5104fe22a4ede8a022196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array of the given shape and initialize it with the initial value. </p>
<p>Storage is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="aa04a8cf8caf6891b467f23a3a5361e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcasacore_1_1Array_1_1uninitializedType.html">uninitializedType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to create an uninitialized array. </p>
<p>This constructor can for example be called with: </p>
<div class="fragment"><div class="line">Array&lt;int&gt; a(shape, Array&lt;int&gt;::uninitialized);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a91dbee48e8ca7e9a7a9176774a474300"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a one-dimensional array from an initializer list. </p>
<p>Example: </p>
<div class="fragment"><div class="line">Array&lt;int&gt; a({5, 6, 7, 8});</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afca1849e5cdbc5ef3fec4b60fab9fd98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After construction, this and other reference the same storage. </p>

</div>
</div>
<a class="anchor" id="abb257b4dd3669dabc1513835bfc31439"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source will be empty after this call. </p>

</div>
</div>
<a class="anchor" id="a34454828b83ffca480f3a82742bd46c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> of a given shape from a pointer. </p>
<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by the specified allocator. </p>
<div class="fragment"><div class="line">FILE *fp =...;</div>
<div class="line"><span class="keyword">typedef</span> DefaultAllocator&lt;int&gt; Alloc;</div>
<div class="line">Alloc::type alloc;</div>
<div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(1, 10);</div>
<div class="line"><span class="keywordtype">int</span> *ptr = alloc.allocate(shape.product());</div>
<div class="line"><span class="keywordtype">size_t</span> nread = fread(ptr, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), shape.product(), fp);</div>
<div class="line">Array&lt;int&gt; ai(shape, ptr, <a class="code" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534babd142c8c0fe4378c955bf07646a218de">TAKE_OVER</a>, <a class="code" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">Alloc::value</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1accee4461916531b4048acf212471d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> of a given shape from a pointer. </p>
<p>Because the pointer is const, a copy is always made. The copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="a91f453c8e68d00052188354f47e47d6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>startIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array from an iterator and a shape. </p>

</div>
</div>
<a class="anchor" id="a34cc68b330b8326055c06fa80a2d8396"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::~<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up storage only if this array was the last reference to it. </p>

</div>
</div>
<a class="anchor" id="a3ba0e6c88766f0cb65c46ae0ab5cd049"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>startIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of constructor taking a Shape, a Templated parameter and an allocator. </p>
<p>This method implements it for when T is integral, in which case the templated parameter is the initial value. </p>

</div>
</div>
<a class="anchor" id="ab70c4c66781cced971bca93fef2d9371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>startIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of constructor taking a Shape, a Templated parameter and an allocator. </p>
<p>This method implements it for when T is NOT integral, in which case the templated parameter is an iterator. </p>

</div>
</div>
<a class="anchor" id="a82e4e4404761b227244f1fec84f3ef58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shapeForSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source will be empty with given shape after this call. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a048a69e51ca86b397f09d0355db5805a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::addDegenerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numAxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This member function returns an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>. </p>
<p>Note that the <code>reform</code> function can also be used to add extra axes. </p>

</div>
</div>
<a class="anchor" id="a95e2b4fa2692b4e80dafe86fa22ce50c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::addDegenerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numAxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35de93ce96905febdc3d0b3ff81d4730"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::adjustLastAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>resizePercentage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resizeIfNeeded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this method to extend or reduce the last dimension of an array. </p>
<p>If sufficient excess capacity exists then the bookkeeping is adjusted to support the new shape. If insufficient storage exists then a new array is allocated (unless resizeIfNeeded is false; then an exception is thrown). If resizing is not required then the data remains untouched; if resizing is required then the data is copied into the new storage. The resizePercentage works the same as for reformOrResize (see above). This method never releases extra storage; use "resize" to do this. <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> may not be sharing storage with another array at call time; an exception will be thrown if the array is shared. Returns true if the array was extension required a <a class="el" href="classcasacore_1_1Array.html#a899d0338a3ca99af49f6d4c398606698" title="Make this array a different shape. ">Array&lt;T&gt;::resize</a> operation. </p>

</div>
</div>
<a class="anchor" id="ac79186dc8903d66e4ae8ee453e935d85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Alloc&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the allocator associated with this array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00234">234</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="abdff977af3402ce92af4e67a30c2eb59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Alloc&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00235">235</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c566146ad72351dafb49b3b0e4af891"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the function to every element of the array. </p>
<p>This modifies the array in place. (TODO this version made the other versions of <a class="el" href="classcasacore_1_1Array.html#a5c566146ad72351dafb49b3b0e4af891" title="Apply the function to every element of the array. ">apply()</a> redundant) </p>

</div>
</div>
<a class="anchor" id="ab0d80d945127590f96e5215c60f8c383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the other array to this array. </p>
<p>If the shapes mismatch, this array is resized. </p>

</div>
</div>
<a class="anchor" id="aea16e489e81114c9272870cea29c1a9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assign_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the values in other to this. </p>
<p>If the array on the left hand side has no elements, then it is resized to be the same size as as the array on the right hand side. Otherwise, the arrays must conform (same shapes). </p>
<div class="fragment"><div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(2,10,10);     <span class="comment">// some shape</span></div>
<div class="line">Array&lt;double&gt; ad(shape);</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">Array&lt;double&gt; ad2;            <span class="comment">// N.B. ad2.nelements() == 0</span></div>
<div class="line">ad2 = ad;                     <span class="comment">// ad2 resizes, then elements</span></div>
<div class="line"><span class="comment">//     are copied.</span></div>
<div class="line">shape = 20;</div>
<div class="line">Array&lt;double&gt; ad3(shape);</div>
<div class="line">ad3 = ad;                     <span class="comment">// Error: arrays do not conform</span></div>
</div><!-- fragment --><p> Note that the assign function can be used to assign a non-conforming array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00285">285</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h_source.html#l00148">casacore::Matrix&lt; Complex &gt;::assign_conforming()</a>, and <a class="el" href="Array_8h_source.html#l00300">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9841e837cafcab1629b175f63e7a797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename MaskAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assign_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T, Alloc, MaskAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>marray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to this those values in marray whose corresponding elements in marray's mask are true. </p>
<h3>Thrown Exceptions</h3>
<ul>
<li>
<a class="el" href="classcasacore_1_1ArrayConformanceError.html" title="An error thrown when two arrays do not conform. ">ArrayConformanceError</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ab74bdbf007cf10bcb37c6c745c87d575"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assign_conforming_implementation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation for assign for copyable types. </p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00285">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::assign_conforming()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b521311b3114b94b8728358582bc0e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assign_conforming_implementation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation for assign for non-copyable types: can not be assigned. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00903">903</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad07d5a061abc30ed33d6f545edb1a030"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::assignBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkType</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the source array to this array. </p>
<p>If <code>checkType==true</code>, it is checked if the underlying template types match. Otherwise, it is only checked in debug mode (for performance). <br/>
The default implementation in <a class="el" href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. ">ArrayBase</a> throws an exception. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a69c12ee118c8fc85cb41d1c85a0c416a">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab04f0eaa446f7521324798154d94845a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the begin iterator object for any array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00859">859</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="MArrayLogical_8h_source.html#l00302">casacore::MArrayLogical_global_functions_MArray_logical_operations::allEQ()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00339">casacore::MArrayLogical_global_functions_MArray_logical_operations::anyEQ()</a>, <a class="el" href="ArrayMath_8h_source.html#l00186">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00301">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00815">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="MArray_8h_source.html#l00193">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="PycBasicData_8h_source.html#l00324">casacore::python::to_list&lt; casacore::Array&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="PycBasicData_8h_source.html#l00343">casacore::python::to_list&lt; casacore::Vector&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="MArrayMath_8h_source.html#l00761">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00748">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00735">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00835">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00709">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00722">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00783">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d952e655170243bd5da55454e854c45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00861">861</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71108e95be60f8e1b01a702bfffe8bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements allocated. </p>
<p>This value is &gt;= to the value returned by <a class="el" href="classcasacore_1_1ArrayBase.html#ad7934dab73a7952f9fbfb7a887efbe34">size()</a>. </p>

</div>
</div>
<a class="anchor" id="a90899c5364c890df123884a6c51b2724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the begin iterator object for a contiguous array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00871">871</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l00186">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00301">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00815">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="MArray_8h_source.html#l00193">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="MArrayMath_8h_source.html#l00761">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00748">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00735">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00835">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00709">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00722">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00783">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f490d3ec79daba7d1f42e0fde2f3d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00873">873</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9b9d96e42e169877d1080413e143ce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a4139ce998a084a34603d0021b8e933dc">contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00875">875</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l00186">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00301">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00815">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="MArray_8h_source.html#l00193">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="MArrayMath_8h_source.html#l00761">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00748">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00735">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00835">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00709">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00722">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00783">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="a626881128eefa0b3d3a46b6395c8057c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#ac43f921a530a6422e69826f950db8de9">const_contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00877">877</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac980e14d9671c994a2b8104bfd6a00ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::checkAssignableType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td>
          <td class="paramname"><em>arrayBase</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00958">958</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d9e8c71a1acb55eb7883b017841c2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::checkBeforeResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called when this array is about to be resized, before any work is done. </p>
<p>Subclasses can throw an exception if the size doesn't match, e.g. if a <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a> is resized to have 3 dimensions. Before this function existed, assign-like functions had to be virtual. However, for non-copyable types, assign can't exist. This is fine for non-virtual methods (they just can't be called), but virtual methods cause the who class to fail to be instantiatable. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00942">942</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0832098b33b80834446a118d904ca0a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::conform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are the shapes identical? </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00596">596</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8cace9f275daa415be269cfd56982ff6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::conform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a06da349f8606994e7d53c73d4166e249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This makes a copy of the array and returns it. </p>
<p>This can be useful for, e.g. making working copies of function arguments that you can write into. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> Array&lt;int&gt; &amp;<a class="code" href="namespacecasacore.html#a494b4a782704d3ce544c6cbaeb786a57">arg</a>)</div>
<div class="line">{</div>
<div class="line">Array&lt;int&gt; tmp(arg.copy());</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that since the copy constructor makes a reference, if we just created used to copy constructor, modifying "tmp" would also modify "arg". Clearly another alternative would simply be: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> Array&lt;int&gt; &amp;arg)</div>
<div class="line">{</div>
<div class="line">Array&lt;int&gt; tmp;</div>
<div class="line">tmp = <a class="code" href="namespacecasacore.html#a494b4a782704d3ce544c6cbaeb786a57">arg</a>;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> which likely would be simpler to understand. (Should <a class="el" href="classcasacore_1_1Array.html#a06da349f8606994e7d53c73d4166e249" title="This makes a copy of the array and returns it. ">copy()</a> be deprecated and removed?)</p>
<p>TODO deprecate </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00341">341</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00341">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bae13da621865b64175890d1721b4e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy using the allocator. </p>

</div>
</div>
<a class="anchor" id="a466ba62f5a479162c737bc4f000c9335"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copyMatchingPart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the matching part of from array to this array. </p>
<p>The matching part is the part with the minimum size for each axis. E.g. if this array has shape [4,5,6] and from array has shape [7,3], the matching part has shape [4,3]. <br/>
Note it is used by the resize function if <code>copyValues==true</code>. </p>

</div>
</div>
<a class="anchor" id="ae1ce8ca72e424546c3760e087ee13a1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copyToContiguousStorage </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="Array_8h_source.html#l00966">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::copyToContiguousStorage()</a>.</p>

</div>
</div>
<a class="anchor" id="ad95005c07e1dcb87d7781198780da3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copyToContiguousStorage </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00908">908</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ca91898e7d439ce98604d0cc3181506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::copyToContiguousStorage </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00966">966</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc2013c620f25a0c13f8d2c83ccbd0b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the beginning of the array. </p>
<p>Note that the array may not be contiguous. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00604">604</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayLogical_8h_source.html#l00257">casacore::ArrayLogical_global_functions_Array_logical_operations::allSame()</a>, <a class="el" href="MArrayMath_8h_source.html#l00260">casacore::MArrayMath_global_functions_MArray_mathematical_operations::boxedArrayMath()</a>, <a class="el" href="MArray_8h_source.html#l00184">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="LSQaips_8h_source.html#l00189">casacore::LSQaips::getErrors()</a>, <a class="el" href="ArrayAccessor_8h_source.html#l00101">casacore::ArrayBaseAccessor&lt; T &gt;::init()</a>, <a class="el" href="MArrayMath_8h_source.html#l00197">casacore::MArrayMath_global_functions_MArray_mathematical_operations::partialArrayMath()</a>, <a class="el" href="HDF5Record_8h_source.html#l00139">casacore::HDF5Record::readArr()</a>, <a class="el" href="LSQaips_8h_source.html#l00127">casacore::LSQaips::solve()</a>, and <a class="el" href="HDF5Record_8h_source.html#l00192">casacore::HDF5Record::writeArr()</a>.</p>

</div>
</div>
<a class="anchor" id="a7641ce351f0a4a2f191cc92be689dba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00606">606</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24a44176d28168780f1d4b0491a75704"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::diagonals </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>firstAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>diag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diagonal of each matrix part in the full array. </p>
<p>The matrices are taken using axes firstAxes and firstAxis+1. diag==0 is main diagonal; diag&gt;0 above the main diagonal; diag&lt;0 below. </p>

</div>
</div>
<a class="anchor" id="aad723c59e8cda0157a1e62ec2366eb74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::doNonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object. </p>
<p>This is the implementation of the nonDegenerate functions. It has a different name to be able to make it virtual without having the "hide virtual function" message when compiling derived classes. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Matrix.html#aa08937b3632ed5b48ec65fb6ddb843e3">casacore::Matrix&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa08937b3632ed5b48ec65fb6ddb843e3">casacore::Matrix&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Matrix.html#aa08937b3632ed5b48ec65fb6ddb843e3">casacore::Matrix&lt; T &gt;</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00473">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::nonDegenerate()</a>.</p>

</div>
</div>
<a class="anchor" id="aee82e2e53970cbcfa50a98ee0f7b5d7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a7f12e1e3b18673abb4015df5da8d34a3">iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00863">863</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="MArrayLogical_8h_source.html#l00302">casacore::MArrayLogical_global_functions_MArray_logical_operations::allEQ()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00339">casacore::MArrayLogical_global_functions_MArray_logical_operations::anyEQ()</a>, <a class="el" href="ArrayMath_8h_source.html#l00186">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00301">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00815">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="MArray_8h_source.html#l00193">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="PycBasicData_8h_source.html#l00324">casacore::python::to_list&lt; casacore::Array&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="PycBasicData_8h_source.html#l00343">casacore::python::to_list&lt; casacore::Vector&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="MArrayMath_8h_source.html#l00761">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00748">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00735">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00835">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00709">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00722">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00783">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="abc19caa1de2d3ffbe09a7ff172260b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#afeb9b461ba061c6e7ab101cf9a84ce03">const_iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00865">865</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20db28372032d34e7d02950785fdb2d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::fixedDimensionality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subclasses can return their dimensionality. </p>
<p>The <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class will make sure that whenever it is resized, the dimensionality is checked. <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>'s constructors do not check the dimensionality, because the subclass hasn't been created yet at that point. Subclasses should therefore make sure to call the constructors appropriately. For classes that return 0, any resize will be allowed. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a38b1dcae49988d1e3b8a745fcfedf8cb">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; rownr_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; size_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a29e59d376ec12c14f5f5ec2d4ffbef56">casacore::Vector&lt; ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#ad855580059b28ccb9801520ec5a745bb">casacore::Cube&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#ad855580059b28ccb9801520ec5a745bb">casacore::Cube&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#ad855580059b28ccb9801520ec5a745bb">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00956">956</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00942">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::checkBeforeResize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab397896c9b7210b9dfedd83fc06fc9ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::freeStorage </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If deleteIt is set, delete "storage". </p>
<p>Normally freeStorage calls will follow calls to getStorage. The reason the pointer is "const" is because only const pointers are released from const arrays. The "storage" pointer is set to zero. TODO this function can not be const for stateful allocators </p>

</div>
</div>
<a class="anchor" id="a122115c70a042d16cecf6eb57f3027c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::freeVStorage </td>
          <td>(</td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a8aae6fbdce7c2151d3cd26a1a4ceb74f">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a9ff3087df9a8e98a289d7d74570b60d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::getSection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to a section of an array. </p>
<p>This is the same as operator(), but can be used in a type-agnostic way. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a4cbedc4114f19979863f691321b46b4a">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a1617712814c24c6c90b6d06eec147810"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::getStorage </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generally use of this should be shunned, except to use a FORTRAN routine or something similar. </p>
<p>Because you can't know the state of the underlying data layout (in particular, if there are increments) sometimes the pointer returned will be to a copy, but often this won't be necessary. A boolean is returned which tells you if this is a copy (and hence the storage must be deleted). Note that if you don't do anything unusual, getStorage followed by freeStorage or putStorage will do the deletion for you (if required). e.g.: </p>
<div class="fragment"><div class="line">Array&lt;int&gt; a(shape);..\.</div>
<div class="line">bool deleteIt; <span class="keywordtype">int</span> *storage = a.getStorage(deleteIt);</div>
<div class="line">foo(storage, a.nelements()); a.puStorage(storage, deleteIt);</div>
<div class="line"><span class="comment">// or a.freeStorage(storage, deleteIt) if a is const.</span></div>
</div><!-- fragment --><p> NB: However, if you only use getStorage, you will have to delete the pointer yourself using <a class="el" href="classcasacore_1_1Array.html#ab397896c9b7210b9dfedd83fc06fc9ca" title="If deleteIt is set, delete &quot;storage&quot;. ">freeStorage()</a>.</p>
<p>It would probably be useful to have corresponding "copyin" "copyout" functions that used a user supplied buffer. Note that deleteIt is set in this function. </p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l01043">casacore::ArrayMath_global_functions_Array_mathematical_operations::expandArray()</a>, and <a class="el" href="Array_8h_source.html#l00632">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::getStorage()</a>.</p>

</div>
</div>
<a class="anchor" id="a02ad27b462537705555b6ac557c841c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::getStorage </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cast is OK because the return pointer will be cast to const </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00632">632</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0968dbe4c417c9bdba1ce08c5c6e85aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::getVStorage </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions behave the same as the corresponding getStorage functions in the derived templated <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> class. </p>
<p>They handle a pointer to a contiguous block of array data. If the array is not contiguous, a copy is used to make it contiguous. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#aaf8e69d7057818e55384f3c3d6309fe7">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="aa78a030f4a8b208b9fe572ca4b5a605b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::getVStorage </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a83398208cfd39d1daed06ad27657bfd7">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="aba45faf8cc4a05311fd12336e3e7dcaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::isUnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> is unique when the container is shared and when nrefs==1. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00914">914</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5373ea1ec1990b5b0bb2bf07c74bcd71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::makeArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an empty array of the same template type. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a486884163e5dd40fafec13c6771fb337">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8fde8c85eef3bdb1b726881992a845"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcasacore_1_1ArrayPositionIterator.html">ArrayPositionIterator</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::makeIterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byDim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a> object of the correct type. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#af8352c6bd85f06f7e5e87ffee0586c70">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8a8c1463075a1f46694364d038f694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::makeSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the steps and the end for a derived class. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00993">993</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="adae2208959f88668ee4c8c4c4ad7aa5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These member functions remove degenerate (ie. </p>
<p>length==1) axes from Arrays. Only axes greater than startingAxis are considered (normally one wants to remove trailing axes). The first two of these functions return an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> reference with axes removed. The latter two functions let this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object reference the 'other' array with degenerated axes removed. <br/>
 Unless throwIfError is false, an exception will be thrown if startingAxis exceeds the array's dimensionality. <br/>
 The functions with argument <code>ignoreAxes</code> do not consider the axes given in that argument. In this way it can be achieved that degenerate axes are kept. <br/>
<b>Caution:</b><em> When the two functions returning <code>void</code> are invoked on a derived object (e;g; <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>), an exception is thrown if removing the degenerate axes from other does not result in a correct number of axes; </em><br/>
 </p>

</div>
</div>
<a class="anchor" id="a990566528d1a321765cae138a80288e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac330f70186897ee7b7c4079cf536bbd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1559203d287234bb4e1e4059c7c9601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00473">473</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d6e355925104f2d060be77039c54b07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::nrefs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of references the underlying storage has assigned to it. </p>
<p>It is 1 unless there are outstanding references to the storage (e.g., through a slice). Normally you have no need to do this since the arrays handle all of the references for you. NB: Even when <a class="el" href="classcasacore_1_1Array.html#a0d6e355925104f2d060be77039c54b07" title="The number of references the underlying storage has assigned to it. ">nrefs()</a>==1, the array might be shared, because the the storage itself might be shared. Therefore, this function should not be used outside debugging. TODO make protected. </p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00914">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::isUnique()</a>.</p>

</div>
</div>
<a class="anchor" id="aec06c5462be201b570837d72487c95a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> is consistent. </p>
<p>This is about the same thing as checking for invariants. If AIPS_DEBUG is defined, this is invoked after construction and on entry to most member functions. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a87c939199d92fe8c993ab8b59f2d816c">casacore::ArrayBase</a>.</p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#aa032dde6c1a05c04f43c3a2a7ade25b6">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; rownr_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; size_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#af4182f0d14f48631b8ce67c2cd3c3c80">casacore::Vector&lt; ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a27c87801ae7c63fcc03660a95e5575fe">casacore::Cube&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a27c87801ae7c63fcc03660a95e5575fe">casacore::Cube&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#a27c87801ae7c63fcc03660a95e5575fe">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4971d08ebde664122131746726739fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a single element of the array. </p>
<p>This is relatively expensive. Extensive indexing should be done through one of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> specializations (<a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a>). </p>

<p>Referenced by <a class="el" href="Cube_8h_source.html#l00182">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator()()</a>, <a class="el" href="Matrix_8h_source.html#l00191">casacore::Matrix&lt; Complex &gt;::operator()()</a>, and <a class="el" href="Vector_8h_source.html#l00215">casacore::Vector&lt; ArgType &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a2620d6fce204e69a0328ddb0dcda1b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf129d788e368e9ac50dd7a5344b9f65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an array section extending from start to end (inclusive). </p>

</div>
</div>
<a class="anchor" id="a27132f638cc8b385f8350a7ff2548981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59e0ddc9b58421a0077952f7d3b815dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Along the ith axis, every inc[i]'th element is chosen. </p>

</div>
</div>
<a class="anchor" id="a2c3b4ec4fb8f949640294c57e8cbbf57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1f6de57e791b5ad24a6af6911c73aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an array section using a <a class="el" href="classcasacore_1_1Slicer.html" title="Specify which elements to extract from an n-dimensional array. ">Slicer</a>. </p>

</div>
</div>
<a class="anchor" id="a3fbbcc796ce0b8b0cb9f497a1e308b8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa5fe17b69dabd3ba65e8f3aa1900918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecasacore.html#a863dbf26a1e602513158145a3fb71183">LogicalArray</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The array is masked by the input LogicalArray. </p>
<p>This mask must conform to the array. </p>

</div>
</div>
<a class="anchor" id="aacf1320c902f0de60d00d4ba24a8bc23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecasacore.html#a863dbf26a1e602513158145a3fb71183">LogicalArray</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a0b580c8ef2f5d621417db0a0b41757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecasacore.html#af8781439f78f62ce1236324ffd1f43c9">MaskedLogicalArray</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The array is masked by the input MaskedLogicalArray. </p>
<p>The mask is effectively the AND of the internal LogicalArray and the internal mask of the MaskedLogicalArray. The MaskedLogicalArray must conform to the array. </p>

</div>
</div>
<a class="anchor" id="af9da620b3a79da1e1f4fd2a7134d11e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecasacore.html#af8781439f78f62ce1236324ffd1f43c9">MaskedLogicalArray</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad676e2ee92bf96cf7517e62f3157c6be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO we should change the semantics. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00300">300</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Cube_8h_source.html#l00125">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator=()</a>, and <a class="el" href="Matrix_8h_source.html#l00180">casacore::Matrix&lt; Complex &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a03b16703273eb8a785ca1921040938a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename MaskAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T, Alloc, MaskAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>marray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classcasacore_1_1Array.html#aea16e489e81114c9272870cea29c1a9a" title="Copy the values in other to this. ">assign_conforming()</a>. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00305">305</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ade4bddd1678989d4bcac2b407082c5fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move operator takes the storage from the given array. </p>
<p>After moving an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>, the source <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> will be left empty. </p>

</div>
</div>
<a class="anchor" id="a887eef6335d241f56c7bde35d6373119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set every element of this array to "value". </p>
<p>In other words, a scalar behaves as if it were a constant conformant array. </p>

</div>
</div>
<a class="anchor" id="a3a19f84dcd3586e41f394cf1df4b73ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subset given by the i-th value of the last axis. </p>
<p>So for a cube it returns the i-th xy plane. For a <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a> it returns the i-th row. The returned array references the original array data; its dimensionality is one less. For a 1-dim array it still returns a 1-dim array. <br/>
<b>Note:</b><em> This function should not be used in tight loops as it is (much) slower than iterating using <a class="el" href="classcasacore_1_1Array.html#ab04f0eaa446f7521324798154d94845a" title="Get the begin iterator object for any array. ">begin()</a> and <a class="el" href="classcasacore_1_1Array.html#aee82e2e53970cbcfa50a98ee0f7b5d7a">end()</a>, ArrayIter, or <a class="el" href="classcasacore_1_1ArrayAccessor.html" title="Fast 1D accessor/iterator for nD array classes. ">ArrayAccessor</a>;</em><br/>
 </p>

</div>
</div>
<a class="anchor" id="a672d9c912bee9f97f2f9eb1a75d8155c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::postTakeStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00933">933</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae39f125ce318a3cc2d680d20d4a590c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::preTakeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre/post processing hook of <a class="el" href="classcasacore_1_1Array.html#a10ea57570f88f8fb9e20d768907fde31" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> for subclasses. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf8787c4df9aba54193a60e03f24d2ea">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a896be01668aabff73bdfbfc5a28afe32">casacore::Cube&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a896be01668aabff73bdfbfc5a28afe32">casacore::Cube&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#a896be01668aabff73bdfbfc5a28afe32">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00931">931</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad2c348ee344355b003622de52c6b8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::putStorage </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteAndCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classcasacore_1_1Array.html#a3ad2c348ee344355b003622de52c6b8a" title="putStorage() is normally called after a call to getStorage() (cf). ">putStorage()</a> is normally called after a call to <a class="el" href="classcasacore_1_1Array.html#a1617712814c24c6c90b6d06eec147810" title="Generally use of this should be shunned, except to use a FORTRAN routine or something similar...">getStorage()</a> (cf). </p>
<p>The "storage" pointer is set to zero. </p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l01043">casacore::ArrayMath_global_functions_Array_mathematical_operations::expandArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bba3e462b2db02178ff5d6535a93736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::putVStorage </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteAndCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ac85b1d41a0f4df0d087816d2c6e51a4a">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a115142801f497760a6859622ec4ea25b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After invocation, this array and other reference the same storage. </p>
<p>That is, modifying an element through one will show up in the other. The arrays appear to be identical; they have the same shape. <br/>
Please note that this function makes it possible to reference a const <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>, thus effectively it makes a const <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> non-const. Although this may seem undesirable at first sight, it is necessary to be able to make references to temporary <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> objects, in particular to <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> slices. Otherwise one first needs to use the copy constructor. </p>

<p>Referenced by <a class="el" href="ValueHolder_8h_source.html#l00177">casacore::ValueHolder::getValue()</a>, <a class="el" href="MArray_8h_source.html#l00104">casacore::MArray&lt; casacore::String &gt;::MArray()</a>, <a class="el" href="MArray_8h_source.html#l00114">casacore::MArray&lt; casacore::String &gt;::reference()</a>, and <a class="el" href="RecordInterface_8h_source.html#l00429">casacore::RecordInterface::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="af3c71b17d672896c23fec325ffe2ad0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T, Alloc&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::reform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is occasionally useful to have an array which access the same storage appear to have a different shape. </p>
<p>For example, turning an N-dimensional array into a <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>. <br/>
When the array data are contiguous, the array can be reshaped to any form as long as the number of elements stays the same. When not contiguous, it is only possible to remove or add axes with length 1. </p>
<div class="fragment"><div class="line">IPosition squareShape(2,5,5);</div>
<div class="line">Array&lt;float&gt; <a class="code" href="namespacecasacore.html#a81061defb229f93e7422132122ea28c7">square</a>(squareShape);</div>
<div class="line">IPosition lineShape(1,25);</div>
<div class="line">Vector&lt;float&gt; line(<a class="code" href="namespacecasacore.html#a81061defb229f93e7422132122ea28c7">square</a>.reform(lineShape));</div>
<div class="line"><span class="comment">// &quot;square&quot;&#39;s storage may now be accessed through Vector &quot;line&quot;</span></div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l01043">casacore::ArrayMath_global_functions_Array_mathematical_operations::expandArray()</a>, and <a class="el" href="ExprNodeSet_8h_source.html#l00507">casacore::TableExprNodeSet::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="acd197a0d301001430c90f2aa0f2f1d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::reformOrResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>resizePercentage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resizeIfNeeded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Having an array that can be reused without requiring reallocation can be useful for large arrays. </p>
<p>The method reformOrResize permits this usage.</p>
<p>The reformOrResize method first attempts to reform the matrix so that it reuses the existing storage for an array with a new shape. If the existing storage will not hold the new shape, then the method will resize the array when resizeIfNeeded is true; if a resize is needed and resizeIfNeeded is false, then an <a class="el" href="classcasacore_1_1ArrayConformanceError.html" title="An error thrown when two arrays do not conform. ">ArrayConformanceError</a> is thrown. The copyDataIfNeeded parameter is passed to resize if resizing is performed. resizePercentage is the percent of additional storage to be addeed when a resize is performed; this allows the allocations to be amortized when the caller expects to be calling this method again in the future. The parameter is used to define an allocation shape which is larger than the newShape by increasing the last dimension by resizePercentage percent (i.e., lastDim = (lastDim * (100 + resizePercentage)) / 100). If resizePercentage &lt;= 0 then resizing uses newShape as-is. Returns true if resizing (allocation) was performed.</p>
<p>To truncate the array so that it no longer holds additional storage, use the resize method.</p>
<p><a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> may not be shared with another <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object during this call. Exception thrown if it is shared. </p>

</div>
</div>
<a class="anchor" id="ad37f38e7fd261f17fcf651b21aa471ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::removeDegenerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove degenerate axes from this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object. </p>
<p>Note it does not make sense to use these functions on a derived object like <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, because it is not possible to remove axes from them. </p>

</div>
</div>
<a class="anchor" id="a83265707db5b4243c324377d2331a4e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::removeDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a899d0338a3ca99af49f6d4c398606698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this array a different shape. </p>
<p>If <code>copyValues==true</code> the old values are copied over to the new array. Copying is done on a per axis basis, thus a subsection with the minimum of the old and new shape is copied. <br/>
Resize without argument is equal to resize(IPosition()). <br/>
It is important to note that if multiple <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> objects reference the same data storage, this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object still references the same data storage as the other <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> objects if the shape does not change. Otherwise this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object references newly allocated storage, while the other <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> objects still reference the existing data storage. <br/>
If you want to be sure that the data storage of this <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> object is not referenced by other <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> objects, the function unique should be called first. </p>

<p>Referenced by <a class="el" href="MArray_8h_source.html#l00133">casacore::MArray&lt; casacore::String &gt;::fill()</a>, <a class="el" href="ExprGroup_8h_source.html#l00393">casacore::TableExprGroupAggr::getArray()</a>, <a class="el" href="MArrayBase_8h_source.html#l00115">casacore::MArrayBase::removeMask()</a>, <a class="el" href="MArray_8h_source.html#l00122">casacore::MArray&lt; casacore::String &gt;::resize()</a>, and <a class="el" href="Vector_8h_source.html#l00168">casacore::Vector&lt; ArgType &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a0574bddabd370088a9259a2e5003d413"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyValues</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the array and optionally copy the values. </p>
<p><br/>
The default implementation in <a class="el" href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. ">ArrayBase</a> throws an exception. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ac2f7037bacc0e615d386201255c5dfbe">casacore::ArrayBase</a>.</p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; T, Alloc &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; rownr_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; size_t &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; casacore::String &gt;</a>, and <a class="el" href="classcasacore_1_1Vector.html#aaea13693846951839854274b26a72abe">casacore::Vector&lt; ArgType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a262338b21281496873e0e7fdd625c5f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set every element of the array to "value." Also could use the assignment operator which assigns an array from a scalar. </p>

</div>
</div>
<a class="anchor" id="acc3e85bc4786177805789fd5ca6785b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::setEndIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the end iterator. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00997">997</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00993">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::makeSteps()</a>.</p>

</div>
</div>
<a class="anchor" id="a9177dcb603e10c263dedc6caa446cf37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this array with another array. </p>
<p>Normally, <a class="el" href="namespacecasacore.html#adfef05b06f78c93c7a75f8b0a485d1fa" title="Swap the first array with the second. ">casacore::swap()</a> should be used instead. </p>

</div>
</div>
<a class="anchor" id="a10ea57570f88f8fb9e20d768907fde31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the data values with those in the pointer <code>storage</code>. </p>
<p>The results are undefined if storage does not point at <a class="el" href="classcasacore_1_1ArrayBase.html#a9c59e870964872ddfeb2de91e05d8b55" title="How many elements does this array have? Product of all axis lengths. ">nelements()</a> or more data elements. After <a class="el" href="classcasacore_1_1Array.html#a10ea57570f88f8fb9e20d768907fde31" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> is called, <code><a class="el" href="classcasacore_1_1Array.html#a0d6e355925104f2d060be77039c54b07" title="The number of references the underlying storage has assigned to it. ">nrefs()</a></code> is 1.</p>
<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code>allocator</code>. If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by <code>allocator</code>. </p>

</div>
</div>
<a class="anchor" id="a7e8f5cb8b048189ee68feee3bf78c1f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since the pointer is const, a copy is always taken. </p>
<p>Storage of a new copy is allocated by the specified allocator. </p>

</div>
</div>
<a class="anchor" id="a52f857fd93c3b794b0068fc3ac24d058"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::tovector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an STL vector from an <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a>. </p>
<p>The created vector is a linear representation of the <a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> memory. See <a class="el" href="classcasacore_1_1Vector.html">Vector</a> for details of the operation and its reverse (i.e. creating a <code><a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a></code> from a <code>vector</code>), and for details of definition and instantiation. </p>

</div>
</div>
<a class="anchor" id="ad5dd6550574969d261d8d658584f86be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::tovector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab566986400a325d01e4495fa754d6dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ensures that this array does not reference any other storage. </p>
<p><br/>
<b>Tip:</b><em> When a section is taken of an array with non-unity strides, storage can be wasted if the array, which originally contained all the data, goes away; <a class="el" href="classcasacore_1_1Array.html#ab566986400a325d01e4495fa754d6dc6" title="This ensures that this array does not reference any other storage. ">unique()</a> also reclaims storage; This is an optimization users don't normally need to understand;</em></p>
<p><em></p>
<div class="fragment"><div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(;;;), blc(;;;), trc(;;;), inc(;;;);</div>
<div class="line">Array&lt;float&gt; af(shape);</div>
<div class="line">inc = 2; <span class="comment">// or anything &gt; 1</span></div>
<div class="line">Array&lt;float&gt; aSection;<a class="code" href="classcasacore_1_1Array.html#a115142801f497760a6859622ec4ea25b">reference</a>(af(blc, trc, inc));</div>
<div class="line">af;<a class="code" href="classcasacore_1_1Array.html#a115142801f497760a6859622ec4ea25b">reference</a>(anotherArray);</div>
<div class="line"><span class="comment">// aSection now references storage that has a stride</span></div>
<div class="line"><span class="comment">// in it, but nothing else is; Storage is wasted;</span></div>
<div class="line">aSection;<a class="code" href="classcasacore_1_1Array.html#ab566986400a325d01e4495fa754d6dc6">unique</a>();</div>
</div><!-- fragment --><p> </em><br/>
 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af6654744bfc7454d925e62cf3c8a58c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcasacore_1_1ArrayIterator.html">ArrayIterator</a>&lt; T, Alloc &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to iterate through Arrays. </p>
<p>Derived classes <a class="el" href="classcasacore_1_1VectorIterator.html" title="Iterate an Vector cursor through another Array. ">VectorIterator</a> and <a class="el" href="classcasacore_1_1MatrixIterator.html" title="Iterate a Matrix cursor through another Array. ">MatrixIterator</a> are probably more useful. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00673">673</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0632a4c3d541a4d5b70d2d0d31718396"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename ST , typename SAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; ST, SAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; ST, SAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="Array_8h_source.html#l01005">casacore::swap()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9d1cd5edd8bc4f4eccbcd285c733ab75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::begin_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pointer is adjusted to point to the first element of the array. </p>
<p>It is not necessarily the same thing as data-&gt;storage() since this array might be a section, e.g. have a blc which shifts us forward into the block. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00986">986</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00871">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::cbegin()</a>, <a class="el" href="Array_8h_source.html#l00604">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::data()</a>, <a class="el" href="Cube_8h_source.html#l00187">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator()()</a>, <a class="el" href="Matrix_8h_source.html#l00195">casacore::Matrix&lt; Complex &gt;::operator()()</a>, <a class="el" href="Vector_8h_source.html#l00219">casacore::Vector&lt; ArgType &gt;::operator()()</a>, <a class="el" href="Vector_8h_source.html#l00211">casacore::Vector&lt; ArgType &gt;::operator[]()</a>, and <a class="el" href="Array_8h_source.html#l00997">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::setEndIter()</a>.</p>

</div>
</div>
<a class="anchor" id="adde725345f50f662f6ce43cb481472d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcasacore_1_1arrays__internal_1_1Storage.html">arrays_internal::Storage</a>&lt;T, Alloc&gt; &gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::data_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer to a Storage that contains the data. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00980">980</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00234">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::allocator()</a>, and <a class="el" href="Array_8h_source.html#l00914">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::isUnique()</a>.</p>

</div>
</div>
<a class="anchor" id="ac63148535b1255ae64669243e997a2c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::end_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The end for an STL-style iteration. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00989">989</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00875">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::cend()</a>, <a class="el" href="Array_8h_source.html#l00863">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::end()</a>, and <a class="el" href="Array_8h_source.html#l00997">casacore::Array&lt; T, std::allocator&lt; T &gt; &gt;::setEndIter()</a>.</p>

</div>
</div>
<a class="anchor" id="a5472f2655dfa4a2d3488bfb4cd3dfef1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcasacore_1_1Array_1_1uninitializedType.html">casacore::Array::uninitializedType</a>  <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T, Alloc &gt;::uninitialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>casa/Arrays/<a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
